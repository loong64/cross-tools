From 18347b5a83bd3664c9434c3c16c90bf463125207 Mon Sep 17 00:00:00 2001
From: Jiahao Xu <xujiahao@loongson.cn>
Date: Sat, 30 Dec 2023 09:34:26 +0800
Subject: [PATCH 14/15] LoongArch: Use LSX for scalar FP rounding with explicit
 rounding mode

In LoongArch FP base ISA there is only the frint.{s/d} instruction which
reads the global rounding mode.  Utilize LSX for explicit rounding mode
even if the operand is scalar.  It seems wasting the CPU power, but
still much faster than calling the library function.

co-authored-By: Xi Ruoyao <xry111@xry111.site>

Change-Id: I7d0af4da52249637a2d2f87e6029a4bb31bbd0bb
---
 src/gcc/config/loongarch/loongarch.c          |  5 ++
 src/gcc/config/loongarch/loongarch.md         | 57 +++++++++++++++++++
 .../loongarch/vect-frint-scalar-no-inexact.c  | 21 +++++++
 .../gcc.target/loongarch/vect-frint-scalar.c  | 39 +++++++++++++
 4 files changed, 122 insertions(+)
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/vect-frint-scalar-no-inexact.c
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/vect-frint-scalar.c

diff --git a/src/gcc/config/loongarch/loongarch.c b/src/gcc/config/loongarch/loongarch.c
index 9aefe2953..0281d4781 100644
--- a/src/gcc/config/loongarch/loongarch.c
+++ b/src/gcc/config/loongarch/loongarch.c
@@ -6302,6 +6302,11 @@ loongarch_can_change_mode_class (machine_mode from, machine_mode to,
   if (LSX_SUPPORTED_MODE_P (from) && LSX_SUPPORTED_MODE_P (to))
     return true;
 
+  /* Allow conversion between LSX vector mode and scalar fp mode. */
+  if ((LSX_SUPPORTED_MODE_P (from) && SCALAR_FLOAT_MODE_P (to))
+      || ((SCALAR_FLOAT_MODE_P (from) && LSX_SUPPORTED_MODE_P (to))))
+    return true;
+
   return !reg_classes_intersect_p (FP_REGS, rclass);
 }
 
diff --git a/src/gcc/config/loongarch/loongarch.md b/src/gcc/config/loongarch/loongarch.md
index ca30c947d..8d3250ad4 100644
--- a/src/gcc/config/loongarch/loongarch.md
+++ b/src/gcc/config/loongarch/loongarch.md
@@ -3725,6 +3725,63 @@
   [(set_attr "type" "unknown")
    (set_attr "mode" "<MODE>")])
 
+(define_mode_attr lsxmode [(SF "v4sf") (DF "v2df")])
+
+(define_expand "ceil<mode>2"
+  [(match_operand:ANYF 0 "register_operand")
+   (match_operand:ANYF 1 "register_operand")]
+  "ISA_HAS_LSX && (flag_fp_int_builtin_inexact || !flag_trapping_math)"
+{
+  machine_mode lsx_mode
+    = <MODE>mode == SFmode ? V4SFmode : V2DFmode;
+  rtx tmp = gen_reg_rtx (lsx_mode);
+  emit_insn (gen_rtx_SET (tmp, gen_rtx_VEC_DUPLICATE (lsx_mode, operands[1])));
+  emit_insn (gen_ceil<lsxmode>2 (tmp, tmp));
+  emit_move_insn (operands[0],
+          lowpart_subreg (<UNITMODE>mode, tmp, lsx_mode));
+  DONE;
+})
+
+(define_expand "floor<mode>2"
+  [(match_operand:ANYF 0 "register_operand")
+   (match_operand:ANYF 1 "register_operand")]
+  "ISA_HAS_LSX && (flag_fp_int_builtin_inexact || !flag_trapping_math)"
+{
+  machine_mode lsx_mode
+    = <MODE>mode == SFmode ? V4SFmode : V2DFmode;
+  rtx tmp = gen_reg_rtx (lsx_mode);
+  emit_insn (gen_rtx_SET (tmp, gen_rtx_VEC_DUPLICATE (lsx_mode, operands[1])));
+  emit_insn (gen_floor<lsxmode>2 (tmp, tmp));
+  emit_move_insn (operands[0],
+          lowpart_subreg (<UNITMODE>mode, tmp, lsx_mode));
+  DONE;
+})
+
+;; Round floating-point numbers to integers
+(define_insn "rint<mode>2"
+  [(set (match_operand:ANYF 0 "register_operand" "=f")
+        (unspec:ANYF [(match_operand:ANYF 1 "register_operand" "f")]
+                      UNSPEC_FRINT))]
+  ""
+  "frint.<fmt>\t%0,%1"
+  [(set_attr "type" "fcvt")
+   (set_attr "mode" "<MODE>")])
+
+(define_expand "btrunc<mode>2"
+  [(match_operand:ANYF 0 "register_operand")
+   (match_operand:ANYF 1 "register_operand")]
+  "ISA_HAS_LSX && (flag_fp_int_builtin_inexact || !flag_trapping_math)"
+{
+  machine_mode lsx_mode
+    = <MODE>mode == SFmode ? V4SFmode : V2DFmode;
+  rtx tmp = gen_reg_rtx (lsx_mode);
+  emit_insn (gen_rtx_SET (tmp, gen_rtx_VEC_DUPLICATE (lsx_mode, operands[1])));
+  emit_insn (gen_btrunc<lsxmode>2 (tmp, tmp));
+  emit_move_insn (operands[0],
+          lowpart_subreg (<UNITMODE>mode, tmp, lsx_mode));
+  DONE;
+})
+
 ;; Synchronization instructions.
 
 (include "sync.md")
diff --git a/src/gcc/testsuite/gcc.target/loongarch/vect-frint-scalar-no-inexact.c b/src/gcc/testsuite/gcc.target/loongarch/vect-frint-scalar-no-inexact.c
new file mode 100644
index 000000000..b56ef5825
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/vect-frint-scalar-no-inexact.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mlsx -fno-fp-int-builtin-inexact" } */
+
+#include "vect-frint-scalar.c"
+
+/* cannot use LSX for these with -fno-fp-int-builtin-inexact,
+   call library function.  */
+/* { dg-final { scan-assembler "\t%plt\\(ceil\\)" } } */
+/* { dg-final { scan-assembler "\t%plt\\(ceilf\\)" } } */
+/* { dg-final { scan-assembler "\t%plt\\(floor\\)" } } */
+/* { dg-final { scan-assembler "\t%plt\\(floorf\\)" } } */
+/* { dg-final { scan-assembler "\t%plt\\(trunc\\)" } } */
+/* { dg-final { scan-assembler "\t%plt\\(truncf\\)" } } */
+
+/* nearbyint is not allowed to rasie FE_INEXACT for decades */
+/* { dg-final { scan-assembler "\t%plt\\(nearbyint\\)" } } */
+/* { dg-final { scan-assembler "\t%plt\\(nearbyintf\\)" } } */
+
+/* rint should just use basic FP operation */
+/* { dg-final { scan-assembler "\tfrint\.s" } } */
+/* { dg-final { scan-assembler "\tfrint\.d" } } */
diff --git a/src/gcc/testsuite/gcc.target/loongarch/vect-frint-scalar.c b/src/gcc/testsuite/gcc.target/loongarch/vect-frint-scalar.c
new file mode 100644
index 000000000..e566fbccc
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/vect-frint-scalar.c
@@ -0,0 +1,39 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mlsx" } */
+
+#define test(func, suffix) \
+__typeof__ (1.##suffix) \
+_##func##suffix (__typeof__ (1.##suffix) x) \
+{ \
+  return __builtin_##func##suffix (x); \
+}
+
+test (ceil, f)
+test (ceil, )
+test (floor, f)
+test (floor, )
+test (trunc, f)
+test (trunc, )
+test (nearbyint, f)
+test (nearbyint, )
+test (rint, f)
+test (rint, )
+
+/* { dg-final { scan-assembler "\tvfrintrp\.s" } } */
+/* { dg-final { scan-assembler "\tvfrintrm\.s" } } */
+/* { dg-final { scan-assembler "\tvfrintrz\.s" } } */
+/* { dg-final { scan-assembler "\tvfrintrp\.d" } } */
+/* { dg-final { scan-assembler "\tvfrintrm\.d" } } */
+/* { dg-final { scan-assembler "\tvfrintrz\.d" } } */
+
+/* must do vreplvei first */
+/* { dg-final { scan-assembler-times "\tvreplvei\.w\t\\\$vr0,\\\$vr0,0" 3 } } */
+/* { dg-final { scan-assembler-times "\tvreplvei\.d\t\\\$vr0,\\\$vr0,0" 3 } } */
+
+/* nearbyint is not allowed to rasie FE_INEXACT for decades */
+/* { dg-final { scan-assembler "\t%plt\\(nearbyint\\)" } } */
+/* { dg-final { scan-assembler "\t%plt\\(nearbyintf\\)" } } */
+
+/* rint should just use basic FP operation */
+/* { dg-final { scan-assembler "\tfrint\.s" } } */
+/* { dg-final { scan-assembler "\tfrint\.d" } } */
-- 
2.39.3

