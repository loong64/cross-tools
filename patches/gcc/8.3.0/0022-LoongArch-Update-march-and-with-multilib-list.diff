From 6df91e02db5b7373761654721d80229aa3270894 Mon Sep 17 00:00:00 2001
From: Yang Yujie <yangyujie@loongson.cn>
Date: Thu, 8 Dec 2022 21:01:31 +0800
Subject: [PATCH 21/28] LoongArch: Update -march and --with-multilib-list

- dedicated options for 2k1000la / 2k1500
- support "-march=abi-default" as the default multilib build option
- support "--with-multilib-list=<abi>/<arch>[,...]"
- simplify the implementation of "-march=native"
- build libraries with "-mstrict-align"

Unless otherwise specified:
- "-march=2k1000la" implies "-mlsx -mstrict-align"
- "-march=2k1500" implies "-mstrict-align"
- "-march=la264" implies "-mstrict-align"
- "-march=native" recognizes 2k1500 and 2k1000la processors as "la264"
  (in this case, LSX is automatically enabled for 2k1000la)

Change-Id: I0ff41db3c4bb71468be9afa472d39dd5d590666c
---
 src/gcc/config.gcc                            | 104 ++++---
 .../loongarch/genopts/loongarch-strings       |   3 +
 .../config/loongarch/genopts/loongarch.opt.in |   9 +
 src/gcc/config/loongarch/la464.md             |  32 +-
 src/gcc/config/loongarch/loongarch-c.c        |   4 +-
 src/gcc/config/loongarch/loongarch-cpu.c      | 279 +++++++++++-------
 src/gcc/config/loongarch/loongarch-cpu.h      |   3 +-
 src/gcc/config/loongarch/loongarch-def.c      |  75 +++--
 src/gcc/config/loongarch/loongarch-def.h      |  25 +-
 src/gcc/config/loongarch/loongarch-opts.c     | 114 +++----
 src/gcc/config/loongarch/loongarch-opts.h     |  31 +-
 src/gcc/config/loongarch/loongarch-str.h      |   3 +
 src/gcc/config/loongarch/loongarch.c          | 103 ++++---
 src/gcc/config/loongarch/loongarch.opt        |   9 +
 src/gcc/config/loongarch/t-linux              |  13 +-
 15 files changed, 480 insertions(+), 327 deletions(-)

diff --git a/src/gcc/config.gcc b/src/gcc/config.gcc
index cde6c0055..38b68ae79 100644
--- a/src/gcc/config.gcc
+++ b/src/gcc/config.gcc
@@ -4465,7 +4465,7 @@ case "${target}" in
 
 		# Perform initial sanity checks on --with-* options.
 		case ${with_arch} in
-		"" | loongarch64 | la464 | la264) ;; # OK, append here.
+		"" | abi-default | loongarch64 | la464 | la264 | 2k1000la | 2k1500) ;; # OK, append here.
 		native)
 			if test x${host} != x${target}; then
 				echo "--with-arch=native is illegal for cross-compiler." 1>&2
@@ -4564,9 +4564,9 @@ case "${target}" in
 		case ${with_abi}/${with_abiext} in
 		lp64*/base)
 			# architectures that support lp64* ABI
-			arch_pattern="native|loongarch64|la464|la264"
+			arch_pattern="native|abi-default|loongarch64|la464|la264|2k1000la|2k1500"
 			# default architecture for lp64* ABI
-			arch_default="loongarch64"
+			arch_default="abi-default"
 			;;
 		*)
 			echo "Unsupported ABI type ${with_abi}/${with_abiext}." 1>&2
@@ -4636,32 +4636,19 @@ case "${target}" in
 		esac
 
 
-		# Infer default with_tune from with_arch: pass 1
+		# Check default with_tune configuration using with_arch.
 		case ${with_arch} in
-		native)
-			tune_pattern="*"
-			tune_default="native"
-			;;
 		loongarch64)
-			tune_pattern="loongarch64|la464|la264"
-			tune_default="la464"
+			tune_pattern="abi-default|loongarch64|la464|la264|2k1000la|2k1500"
 			;;
 		*)
 			# By default, $with_tune == $with_arch
-			tune_pattern="$with_arch"
+			tune_pattern="*"
 			;;
 		esac
 
-		## Set default value for with_tune.
 		case ${with_tune} in
-		"")
-			if test x${tune_default} != x; then
-				with_tune=${tune_default}
-			else
-				with_tune=${tune_pattern}
-			fi
-			;;
-
+		"")	with_tune="none" ;;
 		*)
 			if echo "${with_tune}" | grep -E "^${tune_pattern}$" > /dev/null; then
 				: # OK
@@ -4700,9 +4687,10 @@ case "${target}" in
 			exit 1
 		fi
 
-		unset component idx elem_abi_base elem_abi_ext elem_tmp
+		unset component idx elem_abi_base elem_abi_ext elem_tmp abi_complete
 		for elem in $(echo "${with_multilib_list}" | tr ',' ' '); do
 			idx=0
+			abi_complete=no
 			while true; do
 				idx=$((idx + 1))
 				component=$(echo "${elem}" | awk -F'/' '{print $'"${idx}"'}')
@@ -4724,32 +4712,57 @@ case "${target}" in
 					elem_abi_base="${component}"
 					;;
 
-				2)
-					# Component 2: ABI extension type
+				2|3)
+					# Other components: ABI extension type / default ARCH
 					case ${component} in
 					"" | base)
-						component="base"
-						elem_tmp="ABI_EXT_BASE,"
+						if test x${component} = xbase && test x${idx} = x3; then
+						    echo "ABI extension \"${component}\"" \
+						         "should follow the base ABI type in --with-multilib-list." 1>&2
+						    exit 1
+						fi
+						if test x${abi_complete} = xno; then
+						    elem_abi_ext="base"
+						    loongarch_multilib_list_make="${loongarch_multilib_list_make}" # Add nothing for now.
+						    loongarch_multilib_list_c="${loongarch_multilib_list_c}ABI_EXT_BASE,"
+						    abi_complete=yes
+						fi
+
+						if test x${component} = x; then
+						    # End of component list.
+						    break
+						fi
+						;;
+
+					abi-default | loongarch64 | la464 | la264 | 2k1000la | 2k1500) # OK, append here.
+						# The default ABI extension is "base".
+						if test x${abi_complete} = xno; then
+						    elem_abi_ext="base"
+						    loongarch_multilib_list_make="${loongarch_multilib_list_make}" # Add nothing for now.
+						    loongarch_multilib_list_c="${loongarch_multilib_list_c}ABI_EXT_BASE,"
+						    abi_complete=yes
+						fi
+						# Append -march spec for each multilib variant.
+						loongarch_multilib_list_make="${loongarch_multilib_list_make}/march=${component}"
+						idx=3
 						;;
 					*)
-						echo "Unknown ABI extension \"${component}\" in --with-multilib-list." 1>&2
+						echo "Unknown ABI extension or ARCH type \"${component}\" in --with-multilib-list." 1>&2
 						exit 1
 						;;
 					esac
-					loongarch_multilib_list_c="${loongarch_multilib_list_c}${elem_tmp}"
-					loongarch_multilib_list_make="${loongarch_multilib_list_make}" # Add nothing for now.
-					elem_abi_ext="${component}"
+
 					;;
 
 				*)
-					# Component 3 and on: optional stuff
+					# Component 4 and on: optional stuff
 					case ${component} in
 					"")
 						# End of component list.
 						break
 						;;
 					*)
-						echo "Unknown ABI \"${elem}\" in --with-multilib-list." 1>&2
+						echo "Unknown multilib variant \"${elem}\" in --with-multilib-list." 1>&2
 						exit 1
 						;;
 					esac
@@ -4757,7 +4770,8 @@ case "${target}" in
 				esac
 			done
 
-			if test x${elem_abi_base} = x${with_abi} \
+			if test x${abi_complete} = xyes \
+			&& test x${elem_abi_base} = x${with_abi} \
 			&& test x${elem_abi_ext} = x${with_abiext}; then
 				loongarch_multilib_list_sane=yes
 			fi
@@ -5223,30 +5237,22 @@ case ${target} in
 
 		# Let --with- flags initialize the enum variables from loongarch.opt.
 		# See macro definitions from loongarch-opts.h and loongarch-cpu.h.
-		case ${with_arch} in
-		native)		tm_defines="${tm_defines} DEFAULT_CPU_ARCH=CPU_NATIVE" ;;
-		la464)		tm_defines="${tm_defines} DEFAULT_CPU_ARCH=CPU_LA464" ;;
-		la264)		tm_defines="${tm_defines} DEFAULT_CPU_ARCH=CPU_LA264" ;;
-		loongarch64)	tm_defines="${tm_defines} DEFAULT_CPU_ARCH=CPU_LOONGARCH64" ;;
-		esac
 
-		case ${with_tune} in
-		native)		tm_defines="${tm_defines} DEFAULT_CPU_TUNE=CPU_NATIVE" ;;
-		la464)		tm_defines="${tm_defines} DEFAULT_CPU_TUNE=CPU_LA464" ;;
-		la264)		tm_defines="${tm_defines} DEFAULT_CPU_TUNE=CPU_LA264" ;;
-		loongarch64)	tm_defines="${tm_defines} DEFAULT_CPU_TUNE=CPU_LOONGARCH64" ;;
-		esac
+		# Architecture
+		tm_defines="${tm_defines} DEFAULT_CPU_ARCH=CPU_$(tr a-z- A-Z_ <<< ${with_arch})"
 
-		case ${with_abi} in
-		lp64d)     tm_defines="${tm_defines} DEFAULT_ABI_BASE=ABI_BASE_LP64D" ;;
-		lp64f)     tm_defines="${tm_defines} DEFAULT_ABI_BASE=ABI_BASE_LP64F" ;;
-		lp64s)     tm_defines="${tm_defines} DEFAULT_ABI_BASE=ABI_BASE_LP64S" ;;
-		esac
+		# Microarchitecture
+		tm_defines="${tm_defines} DEFAULT_CPU_TUNE=CPU_$(tr a-z- A-Z_ <<< ${with_tune})"
+
+		# Base ABI type
+		tm_defines="${tm_defines} DEFAULT_ABI_BASE=ABI_BASE_$(tr a-z- A-Z_ <<< ${with_abi})"
 
+		# ABI Extension
 		case ${with_abiext} in
 		base)      tm_defines="${tm_defines} DEFAULT_ABI_EXT=ABI_EXT_BASE" ;;
 		esac
 
+		# FPU adjustment
 		case ${with_fpu} in
 		none)    tm_defines="$tm_defines DEFAULT_ISA_EXT_FPU=ISA_EXT_NOFPU" ;;
 		32)      tm_defines="$tm_defines DEFAULT_ISA_EXT_FPU=ISA_EXT_FPU32" ;;
diff --git a/src/gcc/config/loongarch/genopts/loongarch-strings b/src/gcc/config/loongarch/genopts/loongarch-strings
index 513e5b68d..c7890eddc 100644
--- a/src/gcc/config/loongarch/genopts/loongarch-strings
+++ b/src/gcc/config/loongarch/genopts/loongarch-strings
@@ -23,9 +23,12 @@ OPTSTR_ARCH	      arch
 OPTSTR_TUNE	      tune
 
 STR_CPU_NATIVE	      native
+STR_CPU_ABI_DEFAULT   abi-default
 STR_CPU_LOONGARCH64   loongarch64
 STR_CPU_LA464	      la464
 STR_CPU_LA264	      la264
+STR_CPU_2K1000LA      2k1000la
+STR_CPU_2K1500        2k1500
 
 # Base architecture
 STR_ISA_BASE_LA64V100 la64
diff --git a/src/gcc/config/loongarch/genopts/loongarch.opt.in b/src/gcc/config/loongarch/genopts/loongarch.opt.in
index 4e8809e6d..d90f8efb5 100644
--- a/src/gcc/config/loongarch/genopts/loongarch.opt.in
+++ b/src/gcc/config/loongarch/genopts/loongarch.opt.in
@@ -95,6 +95,9 @@ LoongArch CPU types:
 EnumValue
 Enum(cpu_type) String(@@STR_CPU_NATIVE@@) Value(CPU_NATIVE)
 
+EnumValue
+Enum(cpu_type) String(@@STR_CPU_ABI_DEFAULT@@) Value(CPU_ABI_DEFAULT)
+
 EnumValue
 Enum(cpu_type) String(@@STR_CPU_LOONGARCH64@@) Value(CPU_LOONGARCH64)
 
@@ -104,6 +107,12 @@ Enum(cpu_type) String(@@STR_CPU_LA464@@) Value(CPU_LA464)
 EnumValue
 Enum(cpu_type) String(@@STR_CPU_LA264@@) Value(CPU_LA264)
 
+EnumValue
+Enum(cpu_type) String(@@STR_CPU_2K1000LA@@) Value(CPU_2K1000LA)
+
+EnumValue
+Enum(cpu_type) String(@@STR_CPU_2K1500@@) Value(CPU_2K1500)
+
 m@@OPTSTR_ARCH@@=
 Target RejectNegative Joined Enum(cpu_type) Var(la_opt_cpu_arch) Init(M_OPTION_NOT_SEEN)
 -m@@OPTSTR_ARCH@@=PROCESSOR	Generate code for the given PROCESSOR ISA.
diff --git a/src/gcc/config/loongarch/la464.md b/src/gcc/config/loongarch/la464.md
index 7ac51f190..5a47e1a77 100644
--- a/src/gcc/config/loongarch/la464.md
+++ b/src/gcc/config/loongarch/la464.md
@@ -43,88 +43,88 @@
 ;; Describe instruction reservations.
 
 (define_insn_reservation "la464_arith" 1
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "arith,clz,const,logical,
 			move,nop,shift,signext,slt"))
   "la464_alu1 | la464_alu2")
 
 (define_insn_reservation "la464_branch" 1
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "branch,jump,call,condmove,trap"))
   "la464_alu1 | la464_alu2")
 
 (define_insn_reservation "la464_imul" 7
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "imul"))
   "la464_alu1 | la464_alu2")
 
 (define_insn_reservation "la464_idiv_si" 12
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (and (eq_attr "type" "idiv")
 	    (eq_attr "mode" "SI")))
   "la464_alu1 | la464_alu2")
 
 (define_insn_reservation "la464_idiv_di" 25
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (and (eq_attr "type" "idiv")
 	    (eq_attr "mode" "DI")))
   "la464_alu1 | la464_alu2")
 
 (define_insn_reservation "la464_load" 4
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "load"))
   "la464_mem1 | la464_mem2")
 
 (define_insn_reservation "la464_gpr_fp" 16
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "mftg,mgtf"))
   "la464_mem1")
 
 (define_insn_reservation "la464_fpload" 4
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "fpload"))
   "la464_mem1 | la464_mem2")
 
 (define_insn_reservation "la464_prefetch" 0
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "prefetch,prefetchx"))
   "la464_mem1 | la464_mem2")
 
 (define_insn_reservation "la464_store" 0
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "store,fpstore,fpidxstore"))
   "la464_mem1 | la464_mem2")
 
 (define_insn_reservation "la464_fadd" 4
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "fadd,fmul,fmadd"))
   "la464_falu1 | la464_falu2")
 
 (define_insn_reservation "la464_fcmp" 2
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "fabs,fcmp,fmove,fneg"))
   "la464_falu1 | la464_falu2")
 
 (define_insn_reservation "la464_fcvt" 4
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "fcvt"))
   "la464_falu1 | la464_falu2")
 
 (define_insn_reservation "la464_fdiv_sf" 12
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (and (eq_attr "type" "fdiv,frdiv,fsqrt,frsqrt")
 	    (eq_attr "mode" "SF")))
   "la464_falu1 | la464_falu2")
 
 (define_insn_reservation "la464_fdiv_df" 19
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (and (eq_attr "type" "fdiv,frdiv,fsqrt,frsqrt")
 	    (eq_attr "mode" "DF")))
   "la464_falu1 | la464_falu2")
 
 ;; Force single-dispatch for unknown or multi.
 (define_insn_reservation "la464_unknown" 1
-  (and (match_test "TARGET_TUNE_LA464")
+  (and (match_test "TARGET_uARCH_LA464")
        (eq_attr "type" "unknown,multi,atomic,syncloop"))
   "la464_alu1 + la464_alu2 + la464_falu1
    + la464_falu2 + la464_mem1 + la464_mem2")
diff --git a/src/gcc/config/loongarch/loongarch-c.c b/src/gcc/config/loongarch/loongarch-c.c
index 780a209ec..f8583f7aa 100644
--- a/src/gcc/config/loongarch/loongarch-c.c
+++ b/src/gcc/config/loongarch/loongarch-c.c
@@ -61,8 +61,8 @@ loongarch_cpu_cpp_builtins (cpp_reader *pfile)
   builtin_assert ("cpu=loongarch");
   builtin_define ("__loongarch__");
 
-  LARCH_CPP_SET_PROCESSOR ("_LOONGARCH_ARCH", LARCH_ACTUAL_ARCH);
-  LARCH_CPP_SET_PROCESSOR ("_LOONGARCH_TUNE", LARCH_ACTUAL_TUNE);
+  LARCH_CPP_SET_PROCESSOR ("_LOONGARCH_ARCH", la_target.cpu_arch);
+  LARCH_CPP_SET_PROCESSOR ("_LOONGARCH_TUNE", la_target.cpu_tune);
 
   /* Base architecture / ABI.  */
   if (TARGET_64BIT)
diff --git a/src/gcc/config/loongarch/loongarch-cpu.c b/src/gcc/config/loongarch/loongarch-cpu.c
index 2e2467bf7..a79700cdf 100644
--- a/src/gcc/config/loongarch/loongarch-cpu.c
+++ b/src/gcc/config/loongarch/loongarch-cpu.c
@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tm.h"
 #include "diagnostic-core.h"
 
+#include "loongarch-def.h"
 #include "loongarch-opts.h"
 #include "loongarch-cpu.h"
 #include "loongarch-str.h"
@@ -43,10 +44,7 @@ read_cpucfg_word (int wordno)
   uint32_t ret = 0;
 
   #ifdef __loongarch__
-  __asm__ __volatile__ ("cpucfg %0,%1\n\t"
-			:"=r"(ret)
-			:"r"(wordno)
-			:);
+  __asm__ ("cpucfg %0,%1\n\t" :"=r"(ret) :"r"(wordno));
   #endif
 
   return ret;
@@ -79,128 +77,203 @@ get_native_prid_str (void)
   return (const char*) prid_str;
 }
 
+
 /* Fill property tables for CPU_NATIVE.  */
-unsigned int
-fill_native_cpu_config (int p_arch_native, int p_tune_native)
+void
+fill_native_cpu_config (struct loongarch_target *tgt)
 {
-  int ret_cpu_type;
+  int arch_native_p = tgt->cpu_arch == CPU_NATIVE;
+  int tune_native_p = tgt->cpu_tune == CPU_NATIVE;
+  int native_cpu_type = CPU_NATIVE;
 
   /* Nothing needs to be done unless "-march/tune=native"
      is given or implied.  */
-  if (!(p_arch_native || p_tune_native))
-    return CPU_NATIVE;
+  if (!arch_native_p && !tune_native_p)
+    return;
 
   /* Fill cpucfg_cache with the "cpucfg" instruction.  */
   cache_cpucfg ();
 
-
-  /* Fill: loongarch_cpu_default_isa[CPU_NATIVE].base
-     With: base architecture (ARCH)
-     At:   cpucfg_words[1][1:0] */
-
-  #define NATIVE_BASE_ISA (loongarch_cpu_default_isa[CPU_NATIVE].base)
-  switch (cpucfg_cache[1] & 0x3)
-    {
-      case 0x02:
-	NATIVE_BASE_ISA = ISA_BASE_LA64V100;
-	break;
-
-      default:
-	if (p_arch_native)
-	  fatal_error (UNKNOWN_LOCATION,
-		       "unknown base architecture %<0x%x%>, %qs failed",
-		       (unsigned int) (cpucfg_cache[1] & 0x3),
-		       "-m" OPTSTR_ARCH "=" STR_CPU_NATIVE);
-    }
-
-  /* Fill: loongarch_cpu_default_isa[CPU_NATIVE].fpu
-     With: FPU type (FP, FP_SP, FP_DP)
-     At:   cpucfg_words[2][2:0] */
-
-  #define NATIVE_FPU (loongarch_cpu_default_isa[CPU_NATIVE].fpu)
-  switch (cpucfg_cache[2] & 0x7)
-    {
-      case 0x07:
-	NATIVE_FPU = ISA_EXT_FPU64;
-	break;
-
-      case 0x03:
-	NATIVE_FPU = ISA_EXT_FPU32;
-	break;
-
-      case 0x00:
-	NATIVE_FPU = ISA_EXT_NOFPU;
-	break;
-
-      default:
-	if (p_arch_native)
-	  fatal_error (UNKNOWN_LOCATION,
-		       "unknown FPU type %<0x%x%>, %qs failed",
-		       (unsigned int) (cpucfg_cache[2] & 0x7),
-		       "-m" OPTSTR_ARCH "=" STR_CPU_NATIVE);
-    }
-
-  /* Fill: loongarch_cpu_cache[CPU_NATIVE]
-     With: cache size info
-     At:   cpucfg_words[16:20][31:0] */
-
-  int l1d_present = 0, l1u_present = 0;
-  int l2d_present = 0;
-  uint32_t l1_szword, l2_szword;
-
-  l1u_present |= cpucfg_cache[16] & 3;	      /* bit[1:0]: unified l1 cache */
-  l1d_present |= cpucfg_cache[16] & 4;	      /* bit[2:2]: l1 dcache */
-  l1_szword = l1d_present ? 18 : (l1u_present ? 17 : 0);
-  l1_szword = l1_szword ? cpucfg_cache[l1_szword]: 0;
-
-  l2d_present |= cpucfg_cache[16] & 24;	      /* bit[4:3]: unified l2 cache */
-  l2d_present |= cpucfg_cache[16] & 128;      /* bit[7:7]: l2 dcache */
-  l2_szword = l2d_present ? cpucfg_cache[19]: 0;
-
-  loongarch_cpu_cache[CPU_NATIVE].l1d_line_size
-    = 1 << ((l1_szword & 0x7f000000) >> 24);  /* bit[30:24]: log2(linesize) */
-
-  loongarch_cpu_cache[CPU_NATIVE].l1d_size
-    = (1 << ((l1_szword & 0x00ff0000) >> 16)) /* bit[23:16]: log2(idx) */
-    * ((l1_szword & 0x0000ffff) + 1)	      /* bit[15:0]:  sets - 1 */
-    * (1 << ((l1_szword & 0x7f000000) >> 24)) /* bit[30:24]: log2(linesize) */
-    >> 10;				      /* in kilobytes */
-
-  loongarch_cpu_cache[CPU_NATIVE].l2d_size
-    = (1 << ((l2_szword & 0x00ff0000) >> 16)) /* bit[23:16]: log2(idx) */
-    * ((l2_szword & 0x0000ffff) + 1)	      /* bit[15:0]:  sets - 1 */
-    * (1 << ((l2_szword & 0x7f000000) >> 24)) /* bit[30:24]: log2(linesize) */
-    >> 10;				      /* in kilobytes */
-
-  /* Fill: ret_cpu_type
+  /* Fill: tgt->cpu_arch | tgt->cpu_tune
      With: processor ID (PRID)
      At:   cpucfg_words[0][31:0] */
 
   switch (cpucfg_cache[0] & 0x00ffff00)
   {
     case 0x0014c000:   /* LA464 */
-      ret_cpu_type = CPU_LA464;
+      native_cpu_type = CPU_LA464;
+      break;
+
+    case 0x0014a000:   /* LA264 */
+      native_cpu_type = CPU_LA264;
       break;
 
     default:
-      /* Unknown PRID.  This is generally harmless as long as
-	 the properties above can be obtained via "cpucfg".  */
-      if (p_tune_native)
+      /* Unknown PRID.  */
+      if (tune_native_p)
 	inform (UNKNOWN_LOCATION, "unknown processor ID %<0x%x%>, "
 		"some tuning parameters will fall back to default",
 		cpucfg_cache[0]);
       break;
   }
 
-  /* Properties that cannot be looked up directly using cpucfg.  */
-  loongarch_cpu_issue_rate[CPU_NATIVE]
-    = loongarch_cpu_issue_rate[ret_cpu_type];
-
-  loongarch_cpu_multipass_dfa_lookahead[CPU_NATIVE]
-    = loongarch_cpu_multipass_dfa_lookahead[ret_cpu_type];
-
-  loongarch_cpu_rtx_cost_data[CPU_NATIVE]
-    = loongarch_cpu_rtx_cost_data[ret_cpu_type];
+  /* if -march=native */
+  if (arch_native_p)
+    {
+      int tmp;
+      tgt->cpu_arch = native_cpu_type;
+
+      /* Fill: loongarch_cpu_default_isa[tgt->cpu_arch].base
+	 With: base architecture (ARCH)
+	 At:   cpucfg_words[1][1:0] */
+
+      #define PRESET_ARCH (loongarch_cpu_default_isa[tgt->cpu_arch].base)
+      switch (cpucfg_cache[1] & 0x3)
+	{
+	  case 0x02:
+	    tmp = ISA_BASE_LA64V100;
+	    break;
+
+	  default:
+	    fatal_error (UNKNOWN_LOCATION,
+			 "unknown native base architecture %<0x%x%>, %qs failed",
+			 (unsigned int) (cpucfg_cache[1] & 0x3),
+			 "-m" OPTSTR_ARCH "=" STR_CPU_NATIVE);
+	}
+
+      /* Check consistency with PRID presets.  */
+      if (native_cpu_type != CPU_NATIVE && tmp != PRESET_ARCH)
+	warning (0, "base architecture %qs differs from PRID preset %qs",
+		 loongarch_isa_base_strings[tmp],
+		 loongarch_isa_base_strings[PRESET_ARCH]);
+
+      /* Use the native value anyways.  */
+      PRESET_ARCH = tmp;
+
+      /* Fill: loongarch_cpu_default_isa[tgt->cpu_arch].fpu
+	 With: FPU type (FP, FP_SP, FP_DP)
+	 At:   cpucfg_words[2][2:0] */
+
+      #define PRESET_FPU (loongarch_cpu_default_isa[tgt->cpu_arch].fpu)
+      switch (cpucfg_cache[2] & 0x7)
+	{
+	  case 0x07:
+	    tmp = ISA_EXT_FPU64;
+	    break;
+
+	  case 0x03:
+	    tmp = ISA_EXT_FPU32;
+	    break;
+
+	  case 0x00:
+	    tmp = ISA_EXT_NOFPU;
+	    break;
+
+	  default:
+	    fatal_error (UNKNOWN_LOCATION,
+			 "unknown native FPU type %<0x%x%>, %qs failed",
+			 (unsigned int) (cpucfg_cache[2] & 0x7),
+			 "-m" OPTSTR_ARCH "=" STR_CPU_NATIVE);
+	}
+
+      /* Check consistency with PRID presets.  */
+      if (native_cpu_type != CPU_NATIVE && tmp != PRESET_FPU)
+	warning (0, "floating-point unit %qs differs from PRID preset %qs",
+		 loongarch_isa_ext_strings[tmp],
+		 loongarch_isa_ext_strings[PRESET_FPU]);
+
+      /* Use the native value anyways.  */
+      PRESET_FPU = tmp;
+
+
+      /* Fill: loongarch_cpu_default_isa[CPU_NATIVE].simd
+	 With: SIMD extension type (LSX, LASX)
+	 At:   cpucfg_words[2][7:6] */
+
+      #define PRESET_SIMD (loongarch_cpu_default_isa[tgt->cpu_arch].simd)
+      switch (cpucfg_cache[2] & 0xc0)
+	{
+	  case 0xc0:
+	    tmp = ISA_EXT_SIMD_LASX;
+	    break;
+
+	  case 0x40:
+	    tmp = ISA_EXT_SIMD_LSX;
+	    break;
+
+	  case 0x80:
+	    warning (0, "unknown SIMD extension "
+			"(%qs disabled while %qs is enabled), disabling SIMD",
+			loongarch_isa_ext_strings[ISA_EXT_SIMD_LSX],
+			loongarch_isa_ext_strings[ISA_EXT_SIMD_LASX]);
+
+	  case 0x00:
+	    tmp = 0;
+	    break;
+	}
+
+      /* Check consistency with PRID presets.  */
+      if (native_cpu_type != CPU_NATIVE && tmp != PRESET_SIMD)
+	warning (0, "SIMD extension %qs differs from PRID preset %qs",
+		 loongarch_isa_ext_strings[tmp],
+		 loongarch_isa_ext_strings[PRESET_SIMD]);
+
+      /* Use the native value anyways.  */
+      PRESET_SIMD = tmp;
+    }
 
-  return ret_cpu_type;
+  if (tune_native_p)
+    {
+      tgt->cpu_tune = native_cpu_type;
+
+      /* Fill: loongarch_cpu_cache[tgt->cpu_tune]
+	 With: cache size info
+	 At:   cpucfg_words[16:20][31:0] */
+
+      #define PRESET_CACHE (loongarch_cpu_cache[tgt->cpu_tune])
+      struct loongarch_cache native_cache;
+      int l1d_present = 0, l1u_present = 0;
+      int l2d_present = 0;
+      uint32_t l1_szword, l2_szword;
+
+      l1u_present |= cpucfg_cache[16] & 3;	  /* bit[1:0]: unified l1 */
+      l1d_present |= cpucfg_cache[16] & 4;	  /* bit[2:2]: l1d */
+      l1_szword = l1d_present ? 18 : (l1u_present ? 17 : 0);
+      l1_szword = l1_szword ? cpucfg_cache[l1_szword]: 0;
+
+      l2d_present |= cpucfg_cache[16] & 24;	  /* bit[4:3]: unified l2 */
+      l2d_present |= cpucfg_cache[16] & 128;	  /* bit[7:7]: l2d */
+      l2_szword = l2d_present ? cpucfg_cache[19]: 0;
+
+      native_cache.l1d_line_size
+	= 1 << ((l1_szword & 0x7f000000) >> 24);  /* bit[30:24]: log2(line) */
+
+      native_cache.l1d_size
+	= (1 << ((l1_szword & 0x00ff0000) >> 16)) /* bit[23:16]: log2(idx) */
+	* ((l1_szword & 0x0000ffff) + 1)	  /* bit[15:0]:  sets - 1 */
+	* (1 << ((l1_szword & 0x7f000000) >> 24)) /* bit[30:24]: log2(line) */
+	>> 10;					  /* in kibibytes */
+
+      native_cache.l2d_size
+	= (1 << ((l2_szword & 0x00ff0000) >> 16)) /* bit[23:16]: log2(idx) */
+	* ((l2_szword & 0x0000ffff) + 1)	  /* bit[15:0]:  sets - 1 */
+	* (1 << ((l2_szword & 0x7f000000) >> 24)) /* bit[30:24]: log2(linesz) */
+	>> 10;					  /* in kibibytes */
+
+      if (native_cpu_type != CPU_NATIVE && (
+	  native_cache.l1d_line_size != PRESET_CACHE.l1d_line_size ||
+	  native_cache.l1d_size != PRESET_CACHE.l1d_size ||
+	  native_cache.l2d_size != PRESET_CACHE.l2d_size))
+	warning (0, "native cache info (%<L1 %dK, L2 %dK, %dB%>)"
+		    "differs from PRID preset (%<L1 %dK, L2 %dK, %dB%>)",
+		    native_cache.l1d_size, native_cache.l2d_size,
+		    native_cache.l1d_line_size,
+		    PRESET_CACHE.l1d_size, PRESET_CACHE.l2d_size,
+		    PRESET_CACHE.l1d_line_size);
+
+      /* Use the native value anyways.  */
+      PRESET_CACHE.l1d_line_size = native_cache.l1d_line_size;
+      PRESET_CACHE.l1d_size = native_cache.l1d_size;
+      PRESET_CACHE.l2d_size = native_cache.l2d_size;
+    }
 }
diff --git a/src/gcc/config/loongarch/loongarch-cpu.h b/src/gcc/config/loongarch/loongarch-cpu.h
index d949c226b..08d018372 100644
--- a/src/gcc/config/loongarch/loongarch-cpu.h
+++ b/src/gcc/config/loongarch/loongarch-cpu.h
@@ -21,9 +21,10 @@ along with GCC; see the file COPYING3.  If not see
 #define LOONGARCH_CPU_H
 
 #include "system.h"
+#include "loongarch-def.h"
 
 void cache_cpucfg (void);
-unsigned int fill_native_cpu_config (int p_arch_native, int p_tune_native);
+void fill_native_cpu_config (struct loongarch_target *tgt);
 uint32_t get_native_prid (void);
 const char* get_native_prid_str (void);
 
diff --git a/src/gcc/config/loongarch/loongarch-def.c b/src/gcc/config/loongarch/loongarch-def.c
index 8d99252a9..dcb40b339 100644
--- a/src/gcc/config/loongarch/loongarch-def.c
+++ b/src/gcc/config/loongarch/loongarch-def.c
@@ -21,28 +21,16 @@ along with GCC; see the file COPYING3.  If not see
 #include "loongarch-def.h"
 #include "loongarch-str.h"
 
-/* Default RTX cost initializer.  */
-#define COSTS_N_INSNS(N) ((N) * 4)
-#define DEFAULT_COSTS				\
-    .fp_add		= COSTS_N_INSNS (1),	\
-    .fp_mult_sf		= COSTS_N_INSNS (2),	\
-    .fp_mult_df		= COSTS_N_INSNS (4),	\
-    .fp_div_sf		= COSTS_N_INSNS (6),	\
-    .fp_div_df		= COSTS_N_INSNS (8),	\
-    .int_mult_si	= COSTS_N_INSNS (1),	\
-    .int_mult_di	= COSTS_N_INSNS (1),	\
-    .int_div_si		= COSTS_N_INSNS (4),	\
-    .int_div_di		= COSTS_N_INSNS (6),	\
-    .branch_cost	= 6,			\
-    .memory_latency	= 4
-
 /* CPU property tables.  */
 const char*
 loongarch_cpu_strings[N_TUNE_TYPES] = {
   [CPU_NATIVE]		  = STR_CPU_NATIVE,
+  [CPU_ABI_DEFAULT]	  = STR_CPU_ABI_DEFAULT,
   [CPU_LOONGARCH64]	  = STR_CPU_LOONGARCH64,
   [CPU_LA464]		  = STR_CPU_LA464,
   [CPU_LA264]		  = STR_CPU_LA264,
+  [CPU_2K1000LA]          = STR_CPU_2K1000LA,
+  [CPU_2K1500]            = STR_CPU_2K1500,
 };
 
 struct loongarch_isa
@@ -58,10 +46,20 @@ loongarch_cpu_default_isa[N_ARCH_TYPES] = {
       .simd = ISA_EXT_SIMD_LASX,
   },
   [CPU_LA264] = {
+      .base = ISA_BASE_LA64V100,
+      .fpu = ISA_EXT_FPU64,
+      .simd = 0,
+  },
+  [CPU_2K1000LA] = {
       .base = ISA_BASE_LA64V100,
       .fpu = ISA_EXT_FPU64,
       .simd = ISA_EXT_SIMD_LSX,
   },
+  [CPU_2K1500] = {
+      .base = ISA_BASE_LA64V100,
+      .fpu = ISA_EXT_FPU64,
+      .simd = 0,
+  },
 };
 
 struct loongarch_cache
@@ -79,14 +77,41 @@ loongarch_cpu_cache[N_TUNE_TYPES] = {
       .simultaneous_prefetches = 4,
   },
   [CPU_LA264] = {
-      /* Loongson 2K1000LA specs */
       .l1d_line_size = 64,
       .l1d_size = 32,
       .l2d_size = 1024,
       .simultaneous_prefetches = 4,
   },
+  [CPU_2K1000LA] = {
+      .l1d_line_size = 64,
+      .l1d_size = 32,
+      .l2d_size = 1024,
+      .simultaneous_prefetches = 4,
+  },
+  [CPU_2K1500] = {
+      .l1d_line_size = 64,
+      .l1d_size = 32,
+      .l2d_size = 2048,
+      .simultaneous_prefetches = 4,
+  },
 };
 
+/* RTX costs */
+/* Default RTX cost initializer.  */
+#define COSTS_N_INSNS(N) ((N) * 4)
+#define DEFAULT_COSTS				\
+    .fp_add		= COSTS_N_INSNS (1),	\
+    .fp_mult_sf		= COSTS_N_INSNS (2),	\
+    .fp_mult_df		= COSTS_N_INSNS (4),	\
+    .fp_div_sf		= COSTS_N_INSNS (6),	\
+    .fp_div_df		= COSTS_N_INSNS (8),	\
+    .int_mult_si	= COSTS_N_INSNS (1),	\
+    .int_mult_di	= COSTS_N_INSNS (1),	\
+    .int_div_si		= COSTS_N_INSNS (4),	\
+    .int_div_di		= COSTS_N_INSNS (6),	\
+    .branch_cost	= 6,			\
+    .memory_latency	= 4
+
 /* The following properties cannot be looked up directly using "cpucfg".
  So it is necessary to provide a default value for "unknown native"
  tune targets (i.e. -mtune=native while PRID does not correspond to
@@ -106,10 +131,16 @@ loongarch_cpu_rtx_cost_data[N_TUNE_TYPES] = {
   [CPU_LA264] = {
       DEFAULT_COSTS
   },
+  [CPU_2K1000LA] = {
+      DEFAULT_COSTS
+  },
+  [CPU_2K1500] = {
+      DEFAULT_COSTS
+  },
 };
 
 /* RTX costs to use when optimizing for size.  */
-extern const struct loongarch_rtx_cost_data
+const struct loongarch_rtx_cost_data
 loongarch_rtx_cost_optimize_size = {
     .fp_add	      = 4,
     .fp_mult_sf	      = 4,
@@ -130,6 +161,8 @@ loongarch_cpu_issue_rate[N_TUNE_TYPES] = {
   [CPU_LOONGARCH64]   = 4,
   [CPU_LA464]	      = 4,
   [CPU_LA264]	      = 2,
+  [CPU_2K1000LA]      = 2,
+  [CPU_2K1500]        = 2,
 };
 
 int
@@ -138,6 +171,8 @@ loongarch_cpu_multipass_dfa_lookahead[N_TUNE_TYPES] = {
   [CPU_LOONGARCH64]   = 4,
   [CPU_LA464]	      = 4,
   [CPU_LA264]	      = 4,
+  [CPU_2K1000LA]      = 4,
+  [CPU_2K1500]        = 4,
 };
 
 /* Wiring string definitions from loongarch-str.h to global arrays
@@ -195,12 +230,12 @@ loongarch_switch_strings[] = {
 const struct loongarch_isa
 abi_minimal_isa[N_ABI_BASE_TYPES][N_ABI_EXT_TYPES] = {
   [ABI_BASE_LP64D] = {
-      [ABI_EXT_BASE] = {.base = ISA_BASE_LA64V100, .fpu = ISA_EXT_FPU64},
+      [ABI_EXT_BASE] = {.base = ISA_BASE_LA64V100, .fpu = ISA_EXT_FPU64, .simd = 0},
   },
   [ABI_BASE_LP64F] = {
-      [ABI_EXT_BASE] = {.base = ISA_BASE_LA64V100, .fpu = ISA_EXT_FPU32},
+      [ABI_EXT_BASE] = {.base = ISA_BASE_LA64V100, .fpu = ISA_EXT_FPU32, .simd = 0},
   },
   [ABI_BASE_LP64S] = {
-      [ABI_EXT_BASE] = {.base = ISA_BASE_LA64V100, .fpu = ISA_EXT_NOFPU},
+      [ABI_EXT_BASE] = {.base = ISA_BASE_LA64V100, .fpu = ISA_EXT_NOFPU, .simd = 0},
   },
 };
diff --git a/src/gcc/config/loongarch/loongarch-def.h b/src/gcc/config/loongarch/loongarch-def.h
index 41d9902e5..dea3c599e 100644
--- a/src/gcc/config/loongarch/loongarch-def.h
+++ b/src/gcc/config/loongarch/loongarch-def.h
@@ -142,22 +142,25 @@ struct loongarch_target
 {
   struct loongarch_isa isa;
   struct loongarch_abi abi;
-  unsigned char cpu_arch;   /* CPU_ */
-  unsigned char cpu_tune;   /* same */
-  unsigned char cpu_native; /* same */
-  unsigned char cmodel;	    /* CMODEL_ */
+  unsigned char cpu_arch;     /* CPU_ */
+  unsigned char cpu_tune;     /* same */
+  unsigned char cmodel;	      /* CMODEL_ */
 };
 
 /* CPU properties.  */
 /* index */
 #define CPU_NATIVE	  0
-#define CPU_LOONGARCH64	  1
-#define CPU_LA464	  2
-#define CPU_LA264	  3
-#define N_ARCH_TYPES	  4
-#define N_TUNE_TYPES	  4
-
-/* parallel tables.  */
+#define CPU_ABI_DEFAULT   1
+#define CPU_LOONGARCH64	  2
+#define CPU_LA464	  3
+#define CPU_LA264	  4
+#define CPU_2K1000LA      5
+#define CPU_2K1500        6
+#define N_ARCH_TYPES	  7
+#define N_TUNE_TYPES	  7
+#define CPU_NONE          7
+
+/* parallel tables */
 extern const char* loongarch_cpu_strings[];
 extern struct loongarch_isa loongarch_cpu_default_isa[];
 extern int loongarch_cpu_issue_rate[];
diff --git a/src/gcc/config/loongarch/loongarch-opts.c b/src/gcc/config/loongarch/loongarch-opts.c
index d993636ec..7c907e3d7 100644
--- a/src/gcc/config/loongarch/loongarch-opts.c
+++ b/src/gcc/config/loongarch/loongarch-opts.c
@@ -1,23 +1,3 @@
-/* Subroutines for loongarch-specific option handling.
-   Copyright (C) 2020-2022 Free Software Foundation, Inc.
-   Contributed by Loongson Ltd.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 3, or (at your option)
-any later version.
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
-
 #define IN_TARGET_CODE 1
 
 #include "config.h"
@@ -30,6 +10,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "loongarch-cpu.h"
 #include "loongarch-opts.h"
 #include "loongarch-str.h"
+#include "loongarch-def.h"
 
 struct loongarch_target la_target;
 
@@ -107,7 +88,7 @@ static int isa_fpu_compat_p (const struct loongarch_isa *set1,
 			     const struct loongarch_isa *set2);
 static int abi_compat_p (const struct loongarch_isa *isa,
 			 struct loongarch_abi abi);
-static int abi_default_cpu_arch (struct loongarch_abi abi);
+static int abi_default_cpu_arch (struct loongarch_abi abi, struct loongarch_isa *isa);
 
 /* Checking configure-time defaults.  */
 #ifndef DEFAULT_ABI_BASE
@@ -212,9 +193,8 @@ loongarch_config_target (struct loongarch_target *target,
 
       /* The target ISA is not ready yet, but (isa_required (t.abi)
 	 + forced fpu) is enough for computing the forced base ABI.  */
-      struct loongarch_isa default_isa = isa_required (t.abi);
-      struct loongarch_isa force_isa = default_isa;
       struct loongarch_abi force_abi = t.abi;
+      struct loongarch_isa force_isa = isa_required (t.abi);
       force_isa.fpu = opt_fpu;
       force_abi.base = isa_default_abi (&force_isa).base;
 
@@ -244,16 +224,20 @@ loongarch_config_target (struct loongarch_target *target,
   /* 2.  Target CPU */
   t.cpu_arch = constrained.arch ? opt_arch : DEFAULT_CPU_ARCH;
 
+  /* If cpu_tune is not set using neither --with-tune nor -mtune,
+     the current cpu_arch is used as its default. */
   t.cpu_tune = constrained.tune ? opt_tune
-    : (constrained.arch ? opt_arch : DEFAULT_CPU_TUNE);
+    : (constrained.arch ? opt_arch :
+       (DEFAULT_CPU_TUNE == CPU_NONE ? DEFAULT_CPU_ARCH : DEFAULT_CPU_TUNE));
+
 
+  /* Handle -march/tune=native */
 #ifdef __loongarch__
   /* For native compilers, gather local CPU information
      and fill the "CPU_NATIVE" index of arrays defined in
      loongarch-cpu.c.  */
 
-  t.cpu_native = fill_native_cpu_config (t.cpu_arch == CPU_NATIVE,
-					 t.cpu_tune == CPU_NATIVE);
+  fill_native_cpu_config (&t);
 
 #else
   if (t.cpu_arch == CPU_NATIVE)
@@ -267,11 +251,20 @@ loongarch_config_target (struct loongarch_target *target,
 		 "-m" OPTSTR_TUNE "=" STR_CPU_NATIVE);
 #endif
 
+  /* Handle -march/tune=abi-default */
+  if (t.cpu_tune == CPU_ABI_DEFAULT)
+    t.cpu_tune = abi_default_cpu_arch (t.abi, NULL);
+
+  if (t.cpu_arch == CPU_ABI_DEFAULT)
+    {
+      t.cpu_arch = abi_default_cpu_arch (t.abi, &(t.isa));
+      loongarch_cpu_default_isa[t.cpu_arch] = t.isa;
+    }
+
   /* 3.  Target base ISA */
 config_target_isa:
 
   /* Get default ISA from "-march" or its default value.  */
-
   t.isa = loongarch_cpu_default_isa[t.cpu_arch];
 
   /* Apply incremental changes.  */
@@ -371,7 +364,7 @@ config_target_isa:
     {
       /* Base architecture can only be implied by -march,
 	 so we adjust that first if it is not constrained.  */
-      int fallback_arch = abi_default_cpu_arch (t.abi);
+      int fallback_arch = abi_default_cpu_arch (t.abi, NULL);
 
       if (t.cpu_arch == CPU_NATIVE)
 	warning (0, "your native CPU architecture (%qs) "
@@ -563,16 +556,22 @@ abi_compat_p (const struct loongarch_isa *isa, struct loongarch_abi abi)
 /* The behavior of this function should be consistent
    with config.gcc.  */
 static inline int
-abi_default_cpu_arch (struct loongarch_abi abi)
+abi_default_cpu_arch (struct loongarch_abi abi,
+		      struct loongarch_isa *isa)
 {
-  switch (abi.base)
-    {
-      case ABI_BASE_LP64D:
-      case ABI_BASE_LP64F:
-      case ABI_BASE_LP64S:
-	if (abi.ext == ABI_EXT_BASE)
+  static struct loongarch_isa tmp;
+  if (!isa)
+    isa = &tmp;
+
+  if (abi.ext == ABI_EXT_BASE)
+    switch (abi.base)
+      {
+	case ABI_BASE_LP64D:
+	case ABI_BASE_LP64F:
+	case ABI_BASE_LP64S:
+	  *isa = isa_required (abi);
 	  return CPU_LOONGARCH64;
-    }
+      }
   gcc_unreachable ();
 }
 
@@ -634,18 +633,12 @@ arch_str (const struct loongarch_target *target)
 {
   if (target->cpu_arch == CPU_NATIVE)
     {
-      if (target->cpu_native == CPU_NATIVE)
-	{
-	  /* Describe a native CPU with unknown PRID.  */
-	  const char* isa_string = isa_str (&target->isa, ',');
-	  APPEND_STRING ("PRID: 0x")
-	  APPEND_STRING (get_native_prid_str ())
-	  APPEND_STRING (", ISA features: ")
-	  APPEND_STRING (isa_string)
-	  APPEND1 ('\0')
-	}
-      else
-	APPEND_STRING (loongarch_cpu_strings[target->cpu_native]);
+      /* Describe a native CPU with unknown PRID.  */
+      const char* isa_string = isa_str (&target->isa, ',');
+      APPEND_STRING ("PRID: 0x")
+      APPEND_STRING (get_native_prid_str ())
+      APPEND_STRING (", ISA features: ")
+      APPEND_STRING (isa_string)
     }
   else
     APPEND_STRING (loongarch_cpu_strings[target->cpu_arch]);
@@ -689,10 +682,14 @@ multilib_enabled_abi_list ()
 
 /* option status feedback for "gcc --help=target -Q" */
 void
-loongarch_update_gcc_opt_status (struct gcc_options *opts,
-				 struct gcc_options *opts_set,
-				 struct loongarch_target *target)
+loongarch_update_gcc_opt_status (struct loongarch_target *target,
+				 struct gcc_options *opts,
+				 struct gcc_options *opts_set)
 {
+  /* status of -march and -mtune */
+  opts->x_la_opt_cpu_arch = target->cpu_arch;
+  opts->x_la_opt_cpu_tune = target->cpu_tune;
+
   /* status of -mlsx and -mlasx */
   opts->x_la_opt_switches &= ~OPTION_MASK_LSX;
   opts->x_la_opt_switches &= ~OPTION_MASK_LASX;
@@ -742,19 +739,4 @@ loongarch_update_gcc_opt_status (struct gcc_options *opts,
       default:
 	gcc_unreachable ();
     }
-
-  /* miscellaneous configurations */
-  switch (target->cpu_arch)
-    {
-      case CPU_LA264:
-
-	/* Using -mstrict-align is recommended for 2K1000LA.  */
-	if (!opts_set->x_TARGET_STRICT_ALIGN)
-	  {
-	    opts->x_TARGET_STRICT_ALIGN = 1;
-	    opts_set->x_TARGET_STRICT_ALIGN = 1;
-	  }
-
-	break;
-    }
 }
diff --git a/src/gcc/config/loongarch/loongarch-opts.h b/src/gcc/config/loongarch/loongarch-opts.h
index 596b68a08..c9433de0b 100644
--- a/src/gcc/config/loongarch/loongarch-opts.h
+++ b/src/gcc/config/loongarch/loongarch-opts.h
@@ -42,9 +42,9 @@ loongarch_config_target (struct loongarch_target *target,
 			 int opt_cmodel, int follow_multilib_list);
 
 void
-loongarch_update_gcc_opt_status (struct gcc_options *opts,
-				 struct gcc_options *opts_set,
-				 struct loongarch_target *target);
+loongarch_update_gcc_opt_status (struct loongarch_target *target,
+				 struct gcc_options *opts,
+				 struct gcc_options *opts_set);
 #endif
 
 
@@ -75,25 +75,12 @@ loongarch_update_gcc_opt_status (struct gcc_options *opts,
 				   || la_target.isa.simd == ISA_EXT_SIMD_LASX)
 #define ISA_HAS_LASX		  (la_target.isa.simd == ISA_EXT_SIMD_LASX)
 
-#define TARGET_ARCH_NATIVE	  (la_target.cpu_arch == CPU_NATIVE)
-#define LARCH_ACTUAL_ARCH	  (TARGET_ARCH_NATIVE \
-				   ? (la_target.cpu_native < N_ARCH_TYPES \
-				      ? (la_target.cpu_native) : (CPU_NATIVE)) \
-				      : (la_target.cpu_arch))
-
-#define TARGET_TUNE_NATIVE	(la_target.cpu_tune == CPU_NATIVE)
-#define LARCH_ACTUAL_TUNE		(TARGET_TUNE_NATIVE \
-				 ? (la_target.cpu_native < N_TUNE_TYPES \
-				    ? (la_target.cpu_native) : (CPU_NATIVE)) \
-				    : (la_target.cpu_tune))
-
-#define TARGET_ARCH_LOONGARCH64	  (LARCH_ACTUAL_ARCH == CPU_LOONGARCH64)
-#define TARGET_ARCH_LA464	  (LARCH_ACTUAL_ARCH == CPU_LA464)
-#define TARGET_ARCH_LA264	  (LARCH_ACTUAL_ARCH == CPU_LA264)
-
-#define TARGET_TUNE_LOONGARCH64	  (LARCH_ACTUAL_TUNE == CPU_LOONGARCH64)
-#define TARGET_TUNE_LA464	  (LARCH_ACTUAL_TUNE == CPU_LA464)
-#define TARGET_TUNE_LA264	  (LARCH_ACTUAL_TUNE == CPU_LA264)
+
+/* TARGET_ macros for use in *.md template conditionals */
+#define TARGET_uARCH_LA464	  (la_target.cpu_tune == CPU_LA464)
+#define TARGET_uARCH_LA264	  (la_target.cpu_tune == CPU_LA264 \
+				   || la_target.cpu_tune == CPU_2K1000LA \
+				   || la_target.cpu_tune == CPU_2K1500)
 
 /* Note: optimize_size may vary across functions,
    while -m[no]-memcpy imposes a global constraint.  */
diff --git a/src/gcc/config/loongarch/loongarch-str.h b/src/gcc/config/loongarch/loongarch-str.h
index 26dc0b02b..1fe123f82 100644
--- a/src/gcc/config/loongarch/loongarch-str.h
+++ b/src/gcc/config/loongarch/loongarch-str.h
@@ -27,9 +27,12 @@ along with GCC; see the file COPYING3.  If not see
 #define OPTSTR_TUNE "tune"
 
 #define STR_CPU_NATIVE "native"
+#define STR_CPU_ABI_DEFAULT "abi-default"
 #define STR_CPU_LOONGARCH64 "loongarch64"
 #define STR_CPU_LA464 "la464"
 #define STR_CPU_LA264 "la264"
+#define STR_CPU_2K1000LA "2k1000la"
+#define STR_CPU_2K1500 "2k1500"
 
 #define STR_ISA_BASE_LA64V100 "la64"
 
diff --git a/src/gcc/config/loongarch/loongarch.c b/src/gcc/config/loongarch/loongarch.c
index 7978ab420..9c13d1be7 100644
--- a/src/gcc/config/loongarch/loongarch.c
+++ b/src/gcc/config/loongarch/loongarch.c
@@ -1270,7 +1270,7 @@ loongarch_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)
       emit_insn (gen_rtx_SET (stack_pointer_rtx, gen_rtx_PLUS (Pmode,
 							       stack_pointer_rtx, r12)));
     }
- 
+
   /* Make sure nothing is scheduled before we are done.  */
   emit_insn (gen_blockage ());
 }
@@ -6815,8 +6815,8 @@ loongarch_adjust_cost (rtx_insn *, int dep_type, rtx_insn *, int cost,
 static int
 loongarch_issue_rate (void)
 {
-  if ((unsigned long) LARCH_ACTUAL_TUNE < N_TUNE_TYPES)
-    return loongarch_cpu_issue_rate[LARCH_ACTUAL_TUNE];
+  if ((unsigned long) la_target.cpu_tune < N_TUNE_TYPES)
+    return loongarch_cpu_issue_rate[la_target.cpu_tune];
   else
     return 1;
 }
@@ -6827,8 +6827,8 @@ loongarch_issue_rate (void)
 static int
 loongarch_multipass_dfa_lookahead (void)
 {
-  if ((unsigned long) LARCH_ACTUAL_TUNE < N_ARCH_TYPES)
-    return loongarch_cpu_multipass_dfa_lookahead[LARCH_ACTUAL_TUNE];
+  if ((unsigned long) la_target.cpu_tune < N_ARCH_TYPES)
+    return loongarch_cpu_multipass_dfa_lookahead[la_target.cpu_tune];
   else
     return 0;
 }
@@ -6983,6 +6983,46 @@ loongarch_init_machine_status (void)
   return ggc_cleared_alloc<machine_function> ();
 }
 
+static void
+loongarch_cpu_option_override (struct loongarch_target *target,
+			       struct gcc_options *opts,
+			       struct gcc_options *opts_set)
+{
+  /* strict alignment */
+  switch (target->cpu_arch)
+    {
+      case CPU_LA264:
+      case CPU_2K1000LA:
+      case CPU_2K1500:
+
+	/* Using -mstrict-align is recommended for 2K1000LA/2K1500.  */
+	if (!opts_set->x_TARGET_STRICT_ALIGN)
+	  {
+	    opts->x_TARGET_STRICT_ALIGN = 1;
+	    opts_set->x_TARGET_STRICT_ALIGN = 1;
+	  }
+	break;
+    }
+
+
+  /* software prefetching parameters (-fprefetch-loop-arrays) */
+  maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,
+    loongarch_cpu_cache[target->cpu_tune].simultaneous_prefetches,
+    opts->x_param_values, opts_set->x_param_values);
+
+  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,
+    loongarch_cpu_cache[target->cpu_tune].l1d_line_size,
+    opts->x_param_values, opts_set->x_param_values);
+
+  maybe_set_param_value (PARAM_L1_CACHE_SIZE,
+    loongarch_cpu_cache[target->cpu_tune].l1d_size,
+    opts->x_param_values, opts_set->x_param_values);
+
+  maybe_set_param_value (PARAM_L2_CACHE_SIZE,
+    loongarch_cpu_cache[target->cpu_tune].l2d_size,
+    opts->x_param_values, opts_set->x_param_values);
+}
+
 static void
 loongarch_option_override_internal (struct gcc_options *opts,
 				    struct gcc_options *opts_set)
@@ -6997,7 +7037,8 @@ loongarch_option_override_internal (struct gcc_options *opts,
 			   la_opt_cpu_arch, la_opt_cpu_tune, la_opt_fpu,
 			   la_opt_abi_base, la_opt_abi_ext, la_opt_cmodel, 0);
 
-  loongarch_update_gcc_opt_status (opts, opts_set, &la_target);
+  loongarch_update_gcc_opt_status (&la_target, opts, opts_set);
+  loongarch_cpu_option_override (&la_target, opts, opts_set);
 
   if (TARGET_ABI_LP64)
     flag_pcc_struct_return = 0;
@@ -7006,7 +7047,7 @@ loongarch_option_override_internal (struct gcc_options *opts,
   if (optimize_size)
     loongarch_cost = &loongarch_rtx_cost_optimize_size;
   else
-    loongarch_cost = &loongarch_cpu_rtx_cost_data[LARCH_ACTUAL_TUNE];
+    loongarch_cost = &loongarch_cpu_rtx_cost_data[la_target.cpu_tune];
 
   /* If the user hasn't specified a branch cost, use the processor's
      default.  */
@@ -7016,23 +7057,6 @@ loongarch_option_override_internal (struct gcc_options *opts,
   if (loongarch_vector_access_cost == 0)
     loongarch_vector_access_cost = 5;
 
-  /* Set up parameters to be used in prefetching algorithm. */
-  maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,
-           loongarch_cpu_cache[LARCH_ACTUAL_TUNE].simultaneous_prefetches,
-           opts->x_param_values,
-           opts_set->x_param_values);
-  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,
-           loongarch_cpu_cache[LARCH_ACTUAL_TUNE].l1d_line_size,
-           opts->x_param_values,
-           opts_set->x_param_values);
-  maybe_set_param_value (PARAM_L1_CACHE_SIZE,
-           loongarch_cpu_cache[LARCH_ACTUAL_TUNE].l1d_size,
-           opts->x_param_values,
-           opts_set->x_param_values);
-  maybe_set_param_value (PARAM_L2_CACHE_SIZE,
-           loongarch_cpu_cache[LARCH_ACTUAL_TUNE].l2d_size,
-           opts->x_param_values,
-           opts_set->x_param_values);
 
   /* Enable sw prefetching at -O3 and higher. */
   if (opts->x_flag_prefetch_loop_arrays < 0
@@ -8596,7 +8620,7 @@ loongarch_expand_vec_perm_const_2 (struct expand_vec_perm_d *d)
 	  // Generate subreg for fitting into insn gen function.
 	  rtx conv_op1 = gen_rtx_SUBREG (E_V4DImode, op1_alt, 0);
 	  rtx conv_op0 = gen_rtx_SUBREG (E_V4DImode, op0_alt, 0);
-	  
+
 	  // Adjust op value in temp register.
 	  // op0 = {0,1,2,3}, op1 = {4,5,0,1}
 	  emit_insn (gen_lasx_xvpermi_q_v4di (conv_op1, conv_op1,
@@ -8607,7 +8631,7 @@ loongarch_expand_vec_perm_const_2 (struct expand_vec_perm_d *d)
 
 	  // Remap indices in selector based on the location of index inside
 	  // selector, and vector element numbers in current vector mode.
-	  
+
 	  // Filling low 128bit of new selector.
 	  for (i = 0; i < d->nelt / 2; i += 1)
 	    {
@@ -8712,7 +8736,7 @@ loongarch_expand_vec_perm_const_2 (struct expand_vec_perm_d *d)
 					      conv_op1, GEN_INT (0x01)));
 	  // Remap indices in selector based on the location of index inside
 	  // selector, and vector element numbers in current vector mode.
-	  
+
 	  // Filling low 128bit of new selector.
 	 for (i = 0; i < d->nelt / 2; i += 1)
 	   {
@@ -9228,13 +9252,14 @@ loongarch_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,
   return ok;
 }
 
-/* Implement TARGET_SCHED_REASSOCIATION_WIDTH.  */
-
 static int
-loongarch_sched_reassociation_width (unsigned int opc ATTRIBUTE_UNUSED,
-				     machine_mode mode ATTRIBUTE_UNUSED)
+loongarch_cpu_sched_reassociation_width (struct loongarch_target *target,
+					 unsigned int opc, machine_mode mode)
 {
-  switch (LARCH_ACTUAL_TUNE)
+  /* unreferenced argument */
+  (void) opc;
+
+  switch (target->cpu_tune)
     {
     case CPU_LOONGARCH64:
     case CPU_LA464:
@@ -9252,14 +9277,20 @@ loongarch_sched_reassociation_width (unsigned int opc ATTRIBUTE_UNUSED,
       else if (FLOAT_MODE_P (mode))
           return 4;
       break;
-
-    case CPU_LA264:
-    default:
-      break;
     }
+
+  /* default is 1 */
   return 1;
 }
 
+/* Implement TARGET_SCHED_REASSOCIATION_WIDTH.  */
+
+static int
+loongarch_sched_reassociation_width (unsigned int opc, machine_mode mode)
+{
+  return loongarch_cpu_sched_reassociation_width (&la_target, opc, mode);
+}
+
 /* Implement extract a scalar element from vecotr register */
 
 void
diff --git a/src/gcc/config/loongarch/loongarch.opt b/src/gcc/config/loongarch/loongarch.opt
index c1ecd77b6..1543d40f4 100644
--- a/src/gcc/config/loongarch/loongarch.opt
+++ b/src/gcc/config/loongarch/loongarch.opt
@@ -102,6 +102,9 @@ LoongArch CPU types:
 EnumValue
 Enum(cpu_type) String(native) Value(CPU_NATIVE)
 
+EnumValue
+Enum(cpu_type) String(abi-default) Value(CPU_ABI_DEFAULT)
+
 EnumValue
 Enum(cpu_type) String(loongarch64) Value(CPU_LOONGARCH64)
 
@@ -111,6 +114,12 @@ Enum(cpu_type) String(la464) Value(CPU_LA464)
 EnumValue
 Enum(cpu_type) String(la264) Value(CPU_LA264)
 
+EnumValue
+Enum(cpu_type) String(2k1000la) Value(CPU_2K1000LA)
+
+EnumValue
+Enum(cpu_type) String(2k1500) Value(CPU_2K1500)
+
 march=
 Target RejectNegative Joined Enum(cpu_type) Var(la_opt_cpu_arch) Init(M_OPTION_NOT_SEEN)
 -march=PROCESSOR	Generate code for the given PROCESSOR ISA.
diff --git a/src/gcc/config/loongarch/t-linux b/src/gcc/config/loongarch/t-linux
index 3fb2196f1..a0ce03f2e 100644
--- a/src/gcc/config/loongarch/t-linux
+++ b/src/gcc/config/loongarch/t-linux
@@ -23,7 +23,18 @@ MULTILIB_DIRNAMES = . base/lp64f base/lp64s
 # The GCC driver always gets all abi-related options on the command line.
 # (see loongarch-driver.c:driver_get_normalized_m_opts)
 comma=,
-MULTILIB_REQUIRED = $(subst $(comma), ,$(TM_MULTILIB_CONFIG))
+MULTILIB_REQUIRED = $(foreach mlib,$(subst $(comma), ,$(TM_MULTILIB_CONFIG)),\
+		    $(firstword $(subst /, ,$(mlib))))
+
+SPECS = specs.install
+
+# temporary self_spec when building libraries (e.g. libgcc)
+lib_build_self_spec  = %<mfpu=* %<march=* -march=abi-default -mstrict-align
+lib_build_self_spec += $(foreach mlib,$(subst $(comma), ,$(TM_MULTILIB_CONFIG)),\
+		       %{$(subst /,:-,$(mlib))})
+
+specs: specs.install
+	sed '/^*self_spec:$$/{ n;s/^$$/$(lib_build_self_spec)/g; }' $< > $@
 
 # Multiarch
 ifneq ($(call if_multiarch,yes),yes)
-- 
2.31.1

