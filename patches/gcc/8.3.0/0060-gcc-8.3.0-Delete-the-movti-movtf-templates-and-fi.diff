From c8591b2358f7a684acc3b0da5e142ce7cefe3b68 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Tue, 12 Mar 2024 11:31:09 +0800
Subject: [PATCH v1 1/2] gcc-8.3.0: Delete the movti/movtf templates and fix
 the issues caused by these two templates.

The java virtual machine will give an error when compiling with
gcc8.3.0 -O1. Through debugging, it was found that it was caused
by the two templates of movti/movtf. It is now deleted.

Change-Id: I99b95824c3d54a07b3357ba93517610d44697039
---
 src/gcc/config/loongarch/loongarch.md         | 66 ------------------
 .../g++.target/loongarch/movti-movtf.C        | 67 +++++++++++++++++++
 2 files changed, 67 insertions(+), 66 deletions(-)
 create mode 100644 src/gcc/testsuite/g++.target/loongarch/movti-movtf.C

diff --git a/src/gcc/config/loongarch/loongarch.md b/src/gcc/config/loongarch/loongarch.md
index 8d3250ad4..d9deab3f0 100644
--- a/src/gcc/config/loongarch/loongarch.md
+++ b/src/gcc/config/loongarch/loongarch.md
@@ -1966,72 +1966,6 @@
    (set_attr "mode" "DF")])
 
 
-;; 128-bit integer moves
-
-(define_expand "movti"
-  [(set (match_operand:TI 0)
-	(match_operand:TI 1))]
-  "TARGET_64BIT"
-{
-  if (loongarch_legitimize_move (TImode, operands[0], operands[1]))
-    DONE;
-})
-
-(define_insn "*movti"
-  [(set (match_operand:TI 0 "nonimmediate_operand" "=r,r,r,m")
-	(match_operand:TI 1 "move_operand" "r,i,m,rJ"))]
-  "TARGET_64BIT
-   && (register_operand (operands[0], TImode)
-       || reg_or_0_operand (operands[1], TImode))"
-  { return loongarch_output_move (operands[0], operands[1]); }
-  [(set_attr "move_type" "move,const,load,store")
-   (set (attr "mode")
-    (if_then_else (eq_attr "move_type" "imul")
-		      (const_string "SI")
-		      (const_string "TI")))])
-
-;; 128-bit floating point moves
-
-(define_expand "movtf"
-  [(set (match_operand:TF 0)
-	(match_operand:TF 1))]
-  "TARGET_64BIT"
-{
-  if (loongarch_legitimize_move (TFmode, operands[0], operands[1]))
-    DONE;
-})
-
-;; This pattern handles both hard- and soft-float cases.
-(define_insn "*movtf"
-  [(set (match_operand:TF 0 "nonimmediate_operand" "=r,r,m,f,r,f,m")
-	(match_operand:TF 1 "move_operand" "rG,m,rG,rG,f,m,f"))]
-  "TARGET_64BIT
-   && (register_operand (operands[0], TFmode)
-       || reg_or_0_operand (operands[1], TFmode))"
-  "#"
-  [(set_attr "move_type" "move,load,store,mgtf,mftg,fpload,fpstore")
-   (set_attr "mode" "TF")])
-
-(define_split
-  [(set (match_operand:MOVE64 0 "nonimmediate_operand")
-	(match_operand:MOVE64 1 "move_operand"))]
-  "reload_completed && loongarch_split_move_insn_p (operands[0], operands[1])"
-  [(const_int 0)]
-{
-  loongarch_split_move_insn (operands[0], operands[1], curr_insn);
-  DONE;
-})
-
-(define_split
-  [(set (match_operand:MOVE128 0 "nonimmediate_operand")
-	(match_operand:MOVE128 1 "move_operand"))]
-  "reload_completed && loongarch_split_move_insn_p (operands[0], operands[1])"
-  [(const_int 0)]
-{
-  loongarch_split_move_insn (operands[0], operands[1], curr_insn);
-  DONE;
-})
-
 ;; Emit a doubleword move in which exactly one of the operands is
 ;; a floating-point register.  We can't just emit two normal moves
 ;; because of the constraints imposed by the FPU register model;
diff --git a/src/gcc/testsuite/g++.target/loongarch/movti-movtf.C b/src/gcc/testsuite/g++.target/loongarch/movti-movtf.C
new file mode 100644
index 000000000..a5fb78995
--- /dev/null
+++ b/src/gcc/testsuite/g++.target/loongarch/movti-movtf.C
@@ -0,0 +1,67 @@
+/* { dg-do compile } */
+/* { dg-options "-O1 -mno-strict-align" }*/
+/* {dg-final {scan-assembler-not "_ZN16ObjectStartArray18set_covered_regionE9MemRegion:*.*st.d\t\\\$r6,\\\$r\[0-9\]+,0\n\tst.d\t\\\$r6,$r\[0-9\]+,8" } } */
+
+#include <iostream>
+
+typedef long HeapWord;
+
+class MemRegion
+{
+  friend class VMStructs;
+
+private:
+  HeapWord *_start;
+  size_t _word_size;
+};
+
+class PSVirtualSpace
+{
+
+  const size_t _alignment;
+
+public:
+  ~PSVirtualSpace () {}
+
+  PSVirtualSpace () : _alignment (4096 /*os::vm_page_size()*/) {}
+
+  size_t
+  alignment () const
+  {
+    return _alignment;
+  }
+  inline size_t committed_size () const;
+};
+
+inline size_t
+PSVirtualSpace::committed_size () const
+{
+  return alignment ();
+}
+
+class ObjectStartArray
+{
+  MemRegion _covered_region;
+  PSVirtualSpace _virtual_space;
+
+public:
+  void set_covered_region (MemRegion mr);
+};
+
+using namespace std;
+
+__attribute__ ((noinline)) extern size_t num_bytes_required (MemRegion mr);
+
+void
+ObjectStartArray::set_covered_region (MemRegion mr)
+{
+  _covered_region = mr;
+  size_t requested_size = num_bytes_required (mr);
+  size_t current_size = _virtual_space.committed_size ();
+  if (requested_size == current_size)
+    {
+      return;
+    }
+  cout << "nothing" << endl;
+}
+
-- 
2.20.1

