From 63ffa4be7ca3e77099c7cbf8a2640500cf0ec323 Mon Sep 17 00:00:00 2001
From: Guo Jie <guojie@loongson.cn>
Date: Tue, 11 Oct 2022 20:37:02 +0800
Subject: [PATCH 04/28] Add stack realign support.

Change-Id: I918bc718adae37974d1e89ee256f5df275c926bb
---
 src/gcc/config/loongarch/loongarch.c | 507 +++++++++++++++++++++++----
 src/gcc/config/loongarch/loongarch.h |  17 +-
 2 files changed, 446 insertions(+), 78 deletions(-)

diff --git a/src/gcc/config/loongarch/loongarch.c b/src/gcc/config/loongarch/loongarch.c
index 85fe76f82..92307bfcb 100644
--- a/src/gcc/config/loongarch/loongarch.c
+++ b/src/gcc/config/loongarch/loongarch.c
@@ -61,6 +61,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "target-globals.h"
 #include "tree-pass.h"
 #include "context.h"
+#include "shrink-wrap.h"
 #include "builtins.h"
 #include "rtl-iter.h"
 #include "cfgloop.h"
@@ -803,6 +804,74 @@ loongarch_save_libcall_count (unsigned mask)
   abort ();
 }
 
+/* Find an available register to be used as dynamic realign argument
+   pointer regsiter.  Such a register will be written in prologue and
+   used in begin of body, so it must not be
+	1. parameter passing register.
+	2. GOT pointer.
+   We reuse static-chain register if it is available.  Otherwise, we
+   use r15 for loongarch64(There may be a better choice. TODO).
+
+   Return: the regno of chosen register.  */
+
+static unsigned int
+find_drap_reg (void)
+{
+  tree decl = cfun->decl;
+  /* Always use callee-saved register if there are no caller-saved
+     registers.  */
+  /* Use r15 for nested function or function need static chain.
+     Since function with tail call may use any caller-saved
+     registers in epilogue, DRAP must not use caller-saved
+     register in such case.  */
+  if (DECL_STATIC_CHAIN (decl)
+      || crtl->tail_call_emit)
+    return DRAP_REGNUM;
+
+  return STATIC_CHAIN_REGNUM;
+}
+
+
+/* Return Dynamic Realign Argument Pointer RTX. Now there isn't any.  */
+
+static rtx
+loongarch_get_drap_rtx (void)
+{
+  if (crtl->stack_alignment_needed <= STACK_BOUNDARY
+      || (get_frame_size () == 0 && crtl->args.size == 0))
+    {
+      crtl->stack_realign_needed = false;
+      return NULL;
+    }
+
+  if (stack_realign_drap)
+    {
+      /* Assign DRAP to vDRAP and returns vDRAP */
+      unsigned int regno = find_drap_reg ();
+      rtx drap_vreg;
+      rtx arg_ptr;
+      rtx_insn *seq, *insn;
+
+      arg_ptr = gen_rtx_REG (Pmode, regno);
+      crtl->drap_reg = arg_ptr;
+
+      start_sequence ();
+      drap_vreg = copy_to_reg (arg_ptr);
+      seq = get_insns ();
+      end_sequence ();
+
+      insn = emit_insn_before (seq, NEXT_INSN (entry_of_function ()));
+      if (!optimize)
+	{
+	  add_reg_note (insn, REG_CFA_SET_VDRAP, drap_vreg);
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	}
+      return drap_vreg;
+    }
+  else
+    return NULL;
+}
+
 /* Populate the current function's loongarch_frame_info structure.
 
    LoongArch stack frames grown downward.  High addresses are at the top.
@@ -873,16 +942,23 @@ loongarch_compute_frame_info (void)
       if (loongarch_save_reg_p (regno))
 	frame->fmask |= 1 << (regno - FP_REG_FIRST), num_f_saved++;
 
+  /* Treat drap reg as a callee-saved reg.  */
+  if (stack_realign_drap)
+    frame->mask |= 1 << (find_drap_reg ()), num_x_saved++;
+
   /* At the bottom of the frame are any outgoing stack arguments.  */
-  offset = LARCH_STACK_ALIGN (crtl->outgoing_args_size);
+  offset = LARCH_STACK_ALIGN2 (crtl->outgoing_args_size);
   /* Next are local stack variables.  */
-  offset += LARCH_STACK_ALIGN (get_frame_size ());
+  offset += LARCH_STACK_ALIGN2 (get_frame_size ());
   /* The virtual frame pointer points above the local variables.  */
   frame->frame_pointer_offset = offset;
   /* Next are the callee-saved FPRs.  */
   if (frame->fmask)
     {
-      offset += LARCH_STACK_ALIGN (num_f_saved * UNITS_PER_FP_REG);
+      if (crtl->stack_realign_needed)
+	offset += num_f_saved * UNITS_PER_FP_REG;
+      else
+        offset += LARCH_STACK_ALIGN (num_f_saved * UNITS_PER_FP_REG);
       frame->fp_sp_offset = offset - UNITS_PER_FP_REG;
     }
   else
@@ -890,7 +966,11 @@ loongarch_compute_frame_info (void)
   /* Next are the callee-saved GPRs.  */
   if (frame->mask)
     {
-      unsigned x_save_size = LARCH_STACK_ALIGN (num_x_saved * UNITS_PER_WORD);
+      unsigned x_save_size;
+      if (crtl->stack_realign_needed)
+	x_save_size = num_x_saved * UNITS_PER_WORD;
+      else
+	x_save_size = LARCH_STACK_ALIGN (num_x_saved * UNITS_PER_WORD);
       unsigned num_save_restore
 	= 1 + loongarch_save_libcall_count (frame->mask);
 
@@ -903,13 +983,29 @@ loongarch_compute_frame_info (void)
     }
   else
     frame->gp_sp_offset = offset;
-  frame->gp_sp_offset = offset - UNITS_PER_WORD;
+
   /* The hard frame pointer points above the callee-saved GPRs.  */
-  frame->hard_frame_pointer_offset = offset;
+  if (crtl->stack_realign_needed)
+    frame->hard_frame_pointer_offset = frame->gp_sp_offset; /* For dwarf.  */
+  else
+    frame->hard_frame_pointer_offset = offset;
+
+  /* Realign here for saving space if crtl->stack_realign_needed is true.  */
+  if (stack_realign_drap)
+    offset = LARCH_STACK_ALIGN2 (offset);
+  else if (stack_realign_fp)
+    offset = LARCH_STACK_ALIGN (offset);
+
   /* Above the hard frame pointer is the callee-allocated varags save area.  */
-  offset += LARCH_STACK_ALIGN (cfun->machine->varargs_size);
+  if (stack_realign_fp)
+    offset += LARCH_STACK_ALIGN (cfun->machine->varargs_size);
+  else
+    offset += LARCH_STACK_ALIGN2 (cfun->machine->varargs_size);
   /* Next is the callee-allocated area for pretend stack arguments.  */
-  offset += LARCH_STACK_ALIGN (crtl->args.pretend_args_size);
+  if (stack_realign_fp)
+    offset += LARCH_STACK_ALIGN (crtl->args.pretend_args_size);
+  else
+    offset += LARCH_STACK_ALIGN2 (crtl->args.pretend_args_size);
   /* Arg pointer must be below pretend args, but must be above alignment
      padding.  */
   frame->arg_pointer_offset = offset - crtl->args.pretend_args_size;
@@ -930,8 +1026,6 @@ loongarch_initial_elimination_offset (int from, int to)
 {
   HOST_WIDE_INT src, dest;
 
-  loongarch_compute_frame_info ();
-
   if (to == HARD_FRAME_POINTER_REGNUM)
     dest = cfun->machine->frame.hard_frame_pointer_offset;
   else if (to == STACK_POINTER_REGNUM)
@@ -979,6 +1073,22 @@ loongarch_for_each_saved_reg (HOST_WIDE_INT sp_offset,
 
   /* Save the link register and s-registers.  */
   offset = cfun->machine->frame.gp_sp_offset - sp_offset;
+
+  /* The drap reg and fp reg have been saved in loongarch_expand_prologue
+   * when stack_realign_drap is true.  */
+  if (stack_realign_drap)
+      offset -= UNITS_PER_WORD * cfun->machine->frame.gpr_saved_num;
+
+  /* Save fp reg first for access incoming-args in stack easily
+   * when stack_realign_fp is true.  */
+  if (stack_realign_fp)
+    {
+	loongarch_save_restore_reg (word_mode, HARD_FRAME_POINTER_REGNUM,
+				    offset, fn);
+	cfun->machine->frame.mask &= (~(1LL << HARD_FRAME_POINTER_REGNUM));
+	offset -= UNITS_PER_WORD;
+    }
+
   for (int regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)
     if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))
       {
@@ -986,6 +1096,10 @@ loongarch_for_each_saved_reg (HOST_WIDE_INT sp_offset,
 	offset -= UNITS_PER_WORD;
       }
 
+  /* Undo.  */
+  if (stack_realign_fp)
+	cfun->machine->frame.mask |= (1LL << HARD_FRAME_POINTER_REGNUM);
+
   /* This loop must iterate over the same space as its companion in
      loongarch_compute_frame_info.  */
   offset = cfun->machine->frame.fp_sp_offset - sp_offset;
@@ -1041,14 +1155,20 @@ loongarch_restore_reg (rtx reg, rtx mem)
 static HOST_WIDE_INT
 loongarch_first_stack_step (struct loongarch_frame_info *frame)
 {
+
+  /* Only for fpr/gpr saved regs first when stack_realign_fp is true.  */
+  if (stack_realign_fp)
+    return frame->total_size - frame->frame_pointer_offset;
+
+  HOST_WIDE_INT realign_size = crtl->stack_alignment_needed / BITS_PER_UNIT;
+
   if (IMM12_OPERAND (frame->total_size))
     return frame->total_size;
 
   HOST_WIDE_INT min_first_step
-    = LARCH_STACK_ALIGN (frame->total_size - frame->fp_sp_offset);
+    = LARCH_STACK_ALIGN2 (frame->total_size - frame->fp_sp_offset);
   HOST_WIDE_INT max_first_step = IMM_REACH / 2 - PREFERRED_STACK_BOUNDARY / 8;
   HOST_WIDE_INT min_second_step = frame->total_size - max_first_step;
-  gcc_assert (min_first_step <= max_first_step);
 
   /* As an optimization, use the least-significant bits of the total frame
      size, so that the second adjustment step is just LU12I + ADD.  */
@@ -1057,7 +1177,11 @@ loongarch_first_stack_step (struct loongarch_frame_info *frame)
       && frame->total_size % IMM_REACH >= min_first_step)
     return frame->total_size % IMM_REACH;
 
-  return max_first_step;
+  return crtl->stack_realign_needed ? (max_first_step < realign_size
+				       ? realign_size
+				       : ROUND_DOWN (max_first_step,
+						     realign_size))
+				    : max_first_step;
 }
 
 static void
@@ -1187,27 +1311,170 @@ loongarch_output_probe_stack_range (rtx reg1, rtx reg2, rtx reg3)
 void
 loongarch_expand_prologue (void)
 {
-  struct loongarch_frame_info *frame = &cfun->machine->frame;
-  HOST_WIDE_INT size = frame->total_size;
+  struct loongarch_frame_info *frame;
+  HOST_WIDE_INT size;
   rtx insn;
+  HOST_WIDE_INT realign_size;
+  HOST_WIDE_INT offset;
+  unsigned mask;
+  HOST_WIDE_INT saved_gpr_num = 0;
+
+  /* Finalize crtl->stack_realign_needed and frame_pointer_needed flags.  */
+  if(crtl->stack_realign_needed || (!flag_omit_frame_pointer && optimize))
+    {
+      unsigned int incoming_stack_boundary
+	= (crtl->parm_stack_boundary > PREFERRED_STACK_BOUNDARY
+	   ? crtl->parm_stack_boundary : PREFERRED_STACK_BOUNDARY);
+      unsigned int stack_alignment
+	= (crtl->is_leaf
+	   ? crtl->max_used_stack_slot_alignment
+	   : crtl->stack_alignment_needed);
+      unsigned int stack_realign
+	= (incoming_stack_boundary < stack_alignment);
+
+      if ((get_frame_size () + crtl->outgoing_args_size) == 0
+	  && (crtl->args.size == 0)
+          && frame_pointer_needed
+          && crtl->is_leaf
+          && crtl->sp_is_unchanging
+          && !cfun->calls_alloca
+          && !crtl->calls_eh_return
+          && !(STACK_CHECK_MOVING_SP
+	       && flag_stack_check
+	       && flag_exceptions
+	       && cfun->can_throw_non_call_exceptions))
+	{
+	  /* If drap has been set, but it actually isn't live at the
+	     start of the function, there is no reason to set it up.  */
+	  if (crtl->drap_reg)
+	    {
+	      basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb;
+	      if (! REGNO_REG_SET_P (DF_LR_IN (bb),
+				     REGNO (crtl->drap_reg)))
+		{
+		  crtl->drap_reg = NULL_RTX;
+		  crtl->need_drap = false;
+		}
+	    }
+	  frame_pointer_needed = false;
+	  crtl->stack_realign_needed = false;
+	  crtl->max_used_stack_slot_alignment = incoming_stack_boundary;
+	  crtl->stack_alignment_needed = incoming_stack_boundary;
+	  crtl->stack_alignment_estimated = incoming_stack_boundary;
+	  if (crtl->preferred_stack_boundary > incoming_stack_boundary)
+	    crtl->preferred_stack_boundary = incoming_stack_boundary;
+
+	  df_finish_pass (true);
+	  df_scan_alloc (NULL);
+	  df_scan_blocks ();
+	  df_compute_regs_ever_live (true);
+	  df_analyze ();
+	  loongarch_compute_frame_info();
+	}
+    }
+
+  frame = &cfun->machine->frame;
+  size = frame->total_size;
+
+  mask = frame->mask;
+
+  realign_size = crtl->stack_alignment_needed / BITS_PER_UNIT;
 
   if (flag_stack_usage_info)
     current_function_static_stack_size = size;
 
+  /* When stack_realign_drap is true, save current sp in drap-reg then realign.  */
+  if (stack_realign_drap)
+    {
+      rtx tmp_reg = plus_constant (Pmode, stack_pointer_rtx, 0);
+      insn = emit_insn (gen_rtx_SET (crtl->drap_reg, tmp_reg));
+      RTX_FRAME_RELATED_P (insn) = 1;
+
+      int log2_realigned_bytes = exact_log2 (realign_size);
+      tmp_reg = gen_rtx_REG (Pmode, GP_REG_FIRST);
+      insn = emit_insn (gen_insvdi (stack_pointer_rtx,
+				    GEN_INT (log2_realigned_bytes),
+				    const0_rtx,
+				    tmp_reg));
+      insn = gen_anddi3 (stack_pointer_rtx,
+			 stack_pointer_rtx,
+			 GEN_INT (-realign_size));
+      loongarch_set_frame_expr (insn);
+    }
+
   /* Save the registers.  */
   if ((frame->mask | frame->fmask) != 0)
     {
       HOST_WIDE_INT step1 = MIN (size, loongarch_first_stack_step (frame));
 
-      insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,
-			    GEN_INT (-step1));
-      RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
-      size -= step1;
+      /* Save fp first for dwarf.  */
+      if (stack_realign_drap)
+	{
+	  gcc_assert (step1 % realign_size == 0);
+	  if (frame->mask & (1LL << HARD_FRAME_POINTER_REGNUM))
+	    {
+	      emit_insn (gen_add3_insn (stack_pointer_rtx,
+					stack_pointer_rtx,
+					GEN_INT (-(frame->total_size
+						   - frame->gp_sp_offset))));
+	      step1 -= (frame->total_size - frame->gp_sp_offset);
+	      loongarch_save_restore_reg (word_mode, HARD_FRAME_POINTER_REGNUM,
+					  0, loongarch_save_reg);
+	      cfun->machine->frame.mask
+		= frame->mask & ~(1LL << HARD_FRAME_POINTER_REGNUM);
+	      saved_gpr_num ++;
+	    }
+	  /* Set up the frame pointer, if we're using one.  */
+	  if (frame_pointer_needed)
+	    {
+	      insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);
+	      RTX_FRAME_RELATED_P (insn) = 1;
+
+	      loongarch_emit_stack_tie ();
+	    }
+	}
+
+      if (!IMM12_OPERAND (-step1) && stack_realign_drap)
+	{
+	  loongarch_emit_move (LARCH_PROLOGUE_TEMP (Pmode), GEN_INT (-step1));
+	  emit_insn (gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,
+				LARCH_PROLOGUE_TEMP (Pmode)));
+
+	  /* Describe the effect of the previous instructions.  */
+	  insn = plus_constant (Pmode, stack_pointer_rtx, -step1);
+	  insn = gen_rtx_SET (stack_pointer_rtx, insn);
+	  loongarch_set_frame_expr (insn);
+	}
+      else
+	{
+	  insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,
+				GEN_INT (-step1));
+	  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;
+	}
+
+      if (saved_gpr_num && stack_realign_drap)
+	size -= (step1 + frame->total_size - frame->gp_sp_offset);
+      else
+	size -= step1;
+
+      if (stack_realign_drap && (frame->mask & (1LL << find_drap_reg ())))
+        {
+          offset = cfun->machine->frame.gp_sp_offset - size
+            - UNITS_PER_WORD * saved_gpr_num;
+          loongarch_save_restore_reg (word_mode, find_drap_reg (),
+				      offset, loongarch_save_reg);
+          cfun->machine->frame.mask
+            = frame->mask & ~(1LL << (find_drap_reg ()));
+          saved_gpr_num ++;
+        }
+
+      cfun->machine->frame.gpr_saved_num = saved_gpr_num;
       loongarch_for_each_saved_reg (size, loongarch_save_reg);
+      cfun->machine->frame.mask = mask;
     }
 
   /* Set up the frame pointer, if we're using one.  */
-  if (frame_pointer_needed)
+  if (frame_pointer_needed && !stack_realign_drap)
     {
       insn = gen_add3_insn (hard_frame_pointer_rtx, stack_pointer_rtx,
 			    GEN_INT (frame->hard_frame_pointer_offset - size));
@@ -1216,6 +1483,21 @@ loongarch_expand_prologue (void)
       loongarch_emit_stack_tie ();
     }
 
+  /* Stack realign when stack_realign_fp is true.  */
+  if (stack_realign_fp)
+    {
+      int log2_realigned_bytes = exact_log2 (realign_size);
+      rtx tmp_reg = gen_rtx_REG (Pmode, GP_REG_FIRST);
+      insn = emit_insn (gen_insvdi (stack_pointer_rtx,
+				    GEN_INT (log2_realigned_bytes),
+				    const0_rtx,
+				    tmp_reg));
+      insn = gen_anddi3 (stack_pointer_rtx,
+			 stack_pointer_rtx,
+			 GEN_INT (-realign_size));
+      loongarch_set_frame_expr (insn);
+    }
+
   /* Allocate the rest of the frame.  */
   if ((flag_stack_check == STATIC_BUILTIN_STACK_CHECK
        || flag_stack_clash_protection)
@@ -1230,9 +1512,11 @@ loongarch_expand_prologue (void)
     }
   else
     {
-      /* Allocate the rest of the frame.  */
       if (size > 0)
 	{
+	  if (stack_realign_drap)
+	    gcc_assert (size % realign_size == 0);
+
 	  if (IMM12_OPERAND (-size))
 	    {
 	      insn = gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,
@@ -1280,6 +1564,8 @@ loongarch_expand_epilogue (bool sibcall_p)
   HOST_WIDE_INT step2 = 0;
   rtx ra = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);
   rtx insn;
+  HOST_WIDE_INT offset;
+  HOST_WIDE_INT saved_gpr_num = 0;
 
   /* We need to add memory barrier to prevent read from deallocated stack.  */
   bool need_barrier_p
@@ -1291,72 +1577,120 @@ loongarch_expand_epilogue (bool sibcall_p)
       return;
     }
 
-  /* Move past any dynamic stack allocations.  */
-  if (cfun->calls_alloca)
+  if (!stack_realign_fp)
     {
-      /* Emit a barrier to prevent loads from a deallocated stack.  */
-      loongarch_emit_stack_tie ();
-      need_barrier_p = false;
+      /* Move past any dynamic stack allocations.  */
+      if (cfun->calls_alloca)
+        {
+            /* Emit a barrier to prevent loads from a deallocated stack.  */
+            loongarch_emit_stack_tie ();
+            need_barrier_p = false;
 
-      rtx adjust = GEN_INT (-frame->hard_frame_pointer_offset);
-      if (!IMM12_OPERAND (INTVAL (adjust)))
-	{
-	  loongarch_emit_move (LARCH_PROLOGUE_TEMP (Pmode), adjust);
-	  adjust = LARCH_PROLOGUE_TEMP (Pmode);
-	}
+            rtx adjust = GEN_INT (-frame->hard_frame_pointer_offset);
+            if (!IMM12_OPERAND (INTVAL (adjust)))
+	    {
+	      loongarch_emit_move (LARCH_PROLOGUE_TEMP (Pmode), adjust);
+	      adjust = LARCH_PROLOGUE_TEMP (Pmode);
+	    }
 
-      insn = emit_insn (gen_add3_insn (stack_pointer_rtx,
-				       hard_frame_pointer_rtx,
-				       adjust));
+            insn = emit_insn (gen_add3_insn (stack_pointer_rtx,
+					     hard_frame_pointer_rtx,
+					     adjust));
 
-      rtx dwarf = NULL_RTX;
-      rtx minus_offset = GEN_INT (-frame->hard_frame_pointer_offset);
-      rtx cfa_adjust_value = gen_rtx_PLUS (Pmode,
-					   hard_frame_pointer_rtx,
-					   minus_offset);
+            if (!(stack_realign_drap))
+	      {
+		rtx dwarf = NULL_RTX;
+		rtx minus_offset = GEN_INT (-frame->hard_frame_pointer_offset);
+		rtx cfa_adjust_value = gen_rtx_PLUS (Pmode,
+						     hard_frame_pointer_rtx,
+						     minus_offset);
 
-      rtx cfa_adjust_rtx = gen_rtx_SET (stack_pointer_rtx, cfa_adjust_value);
-      dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, cfa_adjust_rtx, dwarf);
-      RTX_FRAME_RELATED_P (insn) = 1;
+		rtx cfa_adjust_rtx = gen_rtx_SET (stack_pointer_rtx, cfa_adjust_value);
+		dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, cfa_adjust_rtx, dwarf);
+		RTX_FRAME_RELATED_P (insn) = 1;
 
-      REG_NOTES (insn) = dwarf;
-    }
+		REG_NOTES (insn) = dwarf;
+	    }
+        }
 
-  /* If we need to restore registers, deallocate as much stack as
-     possible in the second step without going out of range.  */
-  if ((frame->mask | frame->fmask) != 0)
-    {
-      step2 = loongarch_first_stack_step (frame);
-      step1 -= step2;
-    }
+      /* If we need to restore registers, deallocate as much stack as
+         possible in the second step without going out of range.  */
+      if ((frame->mask | frame->fmask) != 0)
+        {
+          step2 = loongarch_first_stack_step (frame);
+          step1 -= step2;
+        }
 
-  /* Set TARGET to BASE + STEP1.  */
-  if (step1 > 0)
-    {
-      /* Emit a barrier to prevent loads from a deallocated stack.  */
-      loongarch_emit_stack_tie ();
-      need_barrier_p = false;
+      /* Set TARGET to BASE + STEP1.  */
+      if (step1 > 0)
+        {
+          /* Emit a barrier to prevent loads from a deallocated stack.  */
+          loongarch_emit_stack_tie ();
+          need_barrier_p = false;
 
-      /* Get an rtx for STEP1 that we can add to BASE.  */
-      rtx adjust = GEN_INT (step1);
-      if (!IMM12_OPERAND (step1))
-	{
-	  loongarch_emit_move (LARCH_PROLOGUE_TEMP (Pmode), adjust);
-	  adjust = LARCH_PROLOGUE_TEMP (Pmode);
-	}
+          /* Get an rtx for STEP1 that we can add to BASE.  */
+          rtx adjust = GEN_INT (step1);
+          if (!IMM12_OPERAND (step1))
+	    {
+	      loongarch_emit_move (LARCH_PROLOGUE_TEMP (Pmode), adjust);
+	      adjust = LARCH_PROLOGUE_TEMP (Pmode);
+	    }
 
-      insn = emit_insn (gen_add3_insn (stack_pointer_rtx,
-				       stack_pointer_rtx,
-				       adjust));
+          insn = emit_insn (gen_add3_insn (stack_pointer_rtx,
+					   stack_pointer_rtx,
+					   adjust));
 
-      rtx dwarf = NULL_RTX;
-      rtx cfa_adjust_rtx = gen_rtx_PLUS (Pmode, stack_pointer_rtx,
-					 GEN_INT (step2));
+          rtx dwarf = NULL_RTX;
+          rtx cfa_adjust_rtx = gen_rtx_PLUS (Pmode,
+					     stack_pointer_rtx,
+					     GEN_INT (step2));
 
-      dwarf = alloc_reg_note (REG_CFA_DEF_CFA, cfa_adjust_rtx, dwarf);
-      RTX_FRAME_RELATED_P (insn) = 1;
+          dwarf = alloc_reg_note (REG_CFA_DEF_CFA, cfa_adjust_rtx, dwarf);
+          RTX_FRAME_RELATED_P (insn) = 1;
 
-      REG_NOTES (insn) = dwarf;
+          REG_NOTES (insn) = dwarf;
+        }
+
+      /* Restore drap reg and fp reg first when stack_realign_drap is true.  */
+      if (stack_realign_drap)
+        {
+          if (frame->mask & (1LL << HARD_FRAME_POINTER_REGNUM))
+            {
+	      offset = cfun->machine->frame.gp_sp_offset
+		- (frame->total_size - step2) ;
+              loongarch_save_restore_reg (word_mode, HARD_FRAME_POINTER_REGNUM,
+					  offset, loongarch_restore_reg);
+              cfun->machine->frame.mask
+		= frame->mask & ~(1LL << HARD_FRAME_POINTER_REGNUM);
+	      saved_gpr_num ++;
+            }
+          if (frame->mask & (1LL << find_drap_reg ()))
+            {
+              offset = cfun->machine->frame.gp_sp_offset
+		- (frame->total_size - step2) - UNITS_PER_WORD * saved_gpr_num;
+              loongarch_save_restore_reg (word_mode, find_drap_reg (),
+					  offset, loongarch_restore_reg);
+              cfun->machine->frame.mask
+		= frame->mask & ~(1LL << (find_drap_reg ()));
+              saved_gpr_num ++;
+            }
+            cfun->machine->frame.gpr_saved_num = saved_gpr_num;
+        }
+    }
+  else /* stack_realign_fp.  */
+    {
+      /* If we need to restore registers, deallocate as much stack as
+         possible in the second step without going out of range.  */
+      if ((frame->mask | frame->fmask) != 0)
+        {
+          step2 = loongarch_first_stack_step (frame);
+	  rtx tmp_reg = plus_constant (Pmode,
+				       hard_frame_pointer_rtx,
+				       -(frame->hard_frame_pointer_offset
+					 - frame->frame_pointer_offset));
+          insn = emit_insn (gen_rtx_SET (stack_pointer_rtx, tmp_reg));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+        }
     }
 
   /* Restore the registers.  */
@@ -1369,9 +1703,17 @@ loongarch_expand_epilogue (bool sibcall_p)
   /* Deallocate the final bit of the frame.  */
   if (step2 > 0)
     {
-      insn = emit_insn (gen_add3_insn (stack_pointer_rtx,
-				       stack_pointer_rtx,
-				       GEN_INT (step2)));
+      if (stack_realign_drap)
+        {
+          rtx tmp_reg = gen_rtx_REG (Pmode, find_drap_reg ());
+          insn = emit_insn (gen_add3_insn (stack_pointer_rtx,
+					   tmp_reg,
+					   const0_rtx));
+        }
+      else
+        insn = emit_insn (gen_add3_insn (stack_pointer_rtx,
+					 stack_pointer_rtx,
+					 GEN_INT (step2)));
 
       rtx dwarf = NULL_RTX;
       rtx cfa_adjust_rtx = gen_rtx_PLUS (Pmode, stack_pointer_rtx, const0_rtx);
@@ -5682,6 +6024,11 @@ loongarch_frame_pointer_required (void)
 static bool
 loongarch_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)
 {
+  if (stack_realign_fp)
+    return ((from == ARG_POINTER_REGNUM
+	     && to == HARD_FRAME_POINTER_REGNUM)
+	    || (from == FRAME_POINTER_REGNUM
+		&& to == STACK_POINTER_REGNUM));
   return (to == HARD_FRAME_POINTER_REGNUM || to == STACK_POINTER_REGNUM);
 }
 
@@ -10193,6 +10540,9 @@ void loongarch_emit_swrsqrtsf (rtx res, rtx a, machine_mode mode)
 #undef TARGET_FUNCTION_OK_FOR_SIBCALL
 #define TARGET_FUNCTION_OK_FOR_SIBCALL loongarch_function_ok_for_sibcall
 
+#undef TARGET_GET_DRAP_RTX
+#define TARGET_GET_DRAP_RTX loongarch_get_drap_rtx
+
 #undef TARGET_VALID_POINTER_MODE
 #define TARGET_VALID_POINTER_MODE loongarch_valid_pointer_mode
 #undef TARGET_REGISTER_MOVE_COST
@@ -10319,6 +10669,9 @@ void loongarch_emit_swrsqrtsf (rtx res, rtx a, machine_mode mode)
 #undef TARGET_LEGITIMATE_ADDRESS_P
 #define TARGET_LEGITIMATE_ADDRESS_P loongarch_legitimate_address_p
 
+#undef TARGET_COMPUTE_FRAME_LAYOUT
+#define TARGET_COMPUTE_FRAME_LAYOUT loongarch_compute_frame_info
+
 #undef TARGET_FRAME_POINTER_REQUIRED
 #define TARGET_FRAME_POINTER_REQUIRED loongarch_frame_pointer_required
 
diff --git a/src/gcc/config/loongarch/loongarch.h b/src/gcc/config/loongarch/loongarch.h
index a3f95eda9..1efadc13c 100644
--- a/src/gcc/config/loongarch/loongarch.h
+++ b/src/gcc/config/loongarch/loongarch.h
@@ -443,6 +443,9 @@ along with GCC; see the file COPYING3.  If not see
 /* Register in which static-chain is passed to a function.  */
 #define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 20) /* $t8  */
 
+/* DRAP register if static-chain register is unavailable.  */
+#define DRAP_REGNUM (GP_REG_FIRST + 15) /* $t3  */
+
 #define GP_TEMP_FIRST (GP_REG_FIRST + 12)
 #define LARCH_PROLOGUE_TEMP_REGNUM (GP_TEMP_FIRST + 1)
 #define LARCH_PROLOGUE_TEMP2_REGNUM (GP_TEMP_FIRST)
@@ -695,6 +698,9 @@ enum reg_class
 
 #define STACK_BOUNDARY (TARGET_ABI_LP64 ? 128 : 64)
 
+/* Maximum stack alignment.  */
+#define MAX_STACK_ALIGNMENT MAX_OFILE_ALIGNMENT
+
 /* Symbolic macros for the registers used to return integer and floating
    point values.  */
 
@@ -752,10 +758,17 @@ typedef struct {
 
 #define EPILOGUE_USES(REGNO) loongarch_epilogue_uses (REGNO)
 
+#define STACK_ALIGN_SIZE_INTERNAL \
+  (crtl->stack_realign_needed) \
+? (crtl->stack_alignment_needed / BITS_PER_UNIT) \
+: (TARGET_ABI_LP64 ? 16 : 8)
 /* Treat LOC as a byte offset from the stack pointer and round it up
    to the next fully-aligned offset.  */
 #define LARCH_STACK_ALIGN(LOC) \
-  (TARGET_ABI_LP64 ? ROUND_UP ((LOC), 16) : ROUND_UP ((LOC), 8))
+  ROUND_UP ((LOC), TARGET_ABI_LP64 ? 16 : 8)
+
+#define LARCH_STACK_ALIGN2(LOC) \
+  ROUND_UP ((LOC), STACK_ALIGN_SIZE_INTERNAL)
 
 #define MCOUNT_NAME "_mcount"
 
@@ -1218,6 +1231,8 @@ struct GTY (()) loongarch_frame_info
   /* Bit X is set if the function saves or restores GPR X.  */
   unsigned int mask;
 
+  unsigned int gpr_saved_num;
+
   /* Likewise FPR X.  */
   unsigned int fmask;
 
-- 
2.31.1

