From 2e4bdb98686324ec4deb030a8667e1866cc3cf38 Mon Sep 17 00:00:00 2001
From: Jiahao Xu <xujiahao@loongson.cn>
Date: Tue, 1 Nov 2022 09:45:47 +0800
Subject: [PATCH 08/28] Recognize [x]vstelm and [x]vldrepl in combine.

gcc/testsuite/ChangeLog
        * gcc.target/loongarch/lasx-xvstelm.c: New test case.
	* gcc.target/loongarch/lasx-xvldrepl.c: New test case.

Change-Id: Ie76a0ce1ecf72dbebba0ae3af873d9f68f758a6e
---
 src/gcc/config/loongarch/lasx.md              | 64 ++++++++++++++++---
 src/gcc/config/loongarch/loongarch.c          | 14 +---
 src/gcc/config/loongarch/lsx.md               | 34 ++++++++--
 .../gcc.target/loongarch/lasx-xvldrepl.c      | 13 ++++
 .../gcc.target/loongarch/lasx-xvstelm.c       | 12 ++++
 5 files changed, 112 insertions(+), 25 deletions(-)
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/lasx-xvldrepl.c
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/lasx-xvstelm.c

diff --git a/src/gcc/config/loongarch/lasx.md b/src/gcc/config/loongarch/lasx.md
index 6f9bc7c9c..aa0d9d185 100644
--- a/src/gcc/config/loongarch/lasx.md
+++ b/src/gcc/config/loongarch/lasx.md
@@ -1483,8 +1483,8 @@
    (V2DF "V8SI")])
 
 (define_insn "lasx_xvreplgr2vr_<lasxfmt_f>"
-  [(set (match_operand:LASX 0 "register_operand" "=f,f")
-	(vec_duplicate:LASX
+  [(set (match_operand:ILASX 0 "register_operand" "=f,f")
+	(vec_duplicate:ILASX
 	  (match_operand:<UNITMODE> 1 "reg_or_0_operand" "r,J")))]
   "ISA_HAS_LASX"
 {
@@ -2528,14 +2528,14 @@
  [(set_attr "type" "simd_splat")
   (set_attr "mode" "<MODE>")])
 
-  (define_insn "lasx_xvreplve0_<lasxfmt_f>_scalar"
-  [(set (match_operand:FLASX 0 "register_operand" "=f")
-	(unspec:FLASX [(match_operand:<UNITMODE> 1 "register_operand" "f")]
-		     UNSPEC_LASX_XVREPLVE0))]
-  "ISA_HAS_LASX"
-  "xvreplve0.<lasxfmt>\t%u0,%u1"
-  [(set_attr "type" "simd_splat")
-   (set_attr "mode" "<MODE>")])
+(define_insn "lasx_xvreplve0_<lasxfmt_f>_scalar"
+[(set (match_operand:FLASX 0 "register_operand" "=f")
+  (vec_duplicate:FLASX
+    (match_operand:<UNITMODE> 1 "register_operand" "f")))]
+ "ISA_HAS_LASX"
+ "xvreplve0.<lasxfmt>\t%u0,%u1"
+ [(set_attr "type" "simd_splat")
+  (set_attr "mode" "<MODE>")])
 
 (define_insn "lasx_xvreplve0_q"
   [(set (match_operand:V32QI 0 "register_operand" "=f")
@@ -3458,6 +3458,19 @@
    (set_attr "mode" "<MODE>")
    (set_attr "length" "4")])
 
+;; Offset is "0"
+(define_insn "lasx_xvldrepl_<lasxfmt_f>_insn_0"
+  [(set (match_operand:LASX 0 "register_operand" "=f")
+    (vec_duplicate:LASX
+      (mem:<UNITMODE> (match_operand:DI 1 "register_operand" "r"))))]
+  "ISA_HAS_LASX"
+{
+    return "xvldrepl.<lasxfmt>\t%u0,%1,0";
+}
+  [(set_attr "type" "simd_load")
+   (set_attr "mode" "<MODE>")
+   (set_attr "length" "4")])
+
 ;;XVADDWEV.H.B   XVSUBWEV.H.B   XVMULWEV.H.B
 ;;XVADDWEV.H.BU  XVSUBWEV.H.BU  XVMULWEV.H.BU   
 (define_insn "lasx_xv<optab>wev_h_b<u>"
@@ -4787,6 +4800,20 @@
    (set_attr "mode" "<MODE>")
    (set_attr "length" "4")])
 
+;; Offset is "0"
+(define_insn "lasx_xvstelm_<lasxfmt_f>_insn_0"
+  [(set (mem:<UNITMODE> (match_operand:DI 0 "register_operand" "r"))
+    (vec_select:<UNITMODE>
+      (match_operand:LASX_WD 1 "register_operand" "f")
+     (parallel [(match_operand:SI 2 "const_<indeximm256>_operand")])))]
+  "ISA_HAS_LASX"
+{
+    return "xvstelm.<lasxfmt>\t%u1,%0,0,%2";
+}
+  [(set_attr "type" "simd_store")
+   (set_attr "mode" "<MODE>")
+   (set_attr "length" "4")])
+
 (define_insn "lasx_xvinsve0_<lasxfmt_f>"
   [(set (match_operand:LASX_WD 0 "register_operand" "=f")
 	(unspec:LASX_WD [(match_operand:LASX_WD 1 "register_operand" "0")
@@ -5026,3 +5053,20 @@
         const0_rtx));
   DONE;
 })
+
+;; merge vec_unpacks_hi_v8sf/vec_unpacks_lo_v8sf
+(define_peephole
+  [(set (match_operand:V4DF 0 "register_operand")
+    (float_extend:V4DF (vec_select:V4SF
+                 (match_operand:V8SF 1 "register_operand")
+                 (parallel [(const_int 0) (const_int 1)
+                            (const_int 2) (const_int 3)]))))
+   (set (match_operand:V4DF 2 "register_operand")
+    (float_extend:V4DF (vec_select:V4SF
+                 (match_operand:V8SF 3 "register_operand")
+                 (parallel [(const_int 4) (const_int 5)
+                            (const_int 6) (const_int 7)]))))]
+  "ISA_HAS_LASX && rtx_equal_p (operands[1], operands[3])"
+{
+  return "xvpermi.d\t%u1,%u1,0xd8\n\txvfcvtl.d.s\t%u0,%u1\n\txvfcvth.d.s\t%u1,%u1";
+})
diff --git a/src/gcc/config/loongarch/loongarch.c b/src/gcc/config/loongarch/loongarch.c
index 5963069fd..c4ec73db3 100644
--- a/src/gcc/config/loongarch/loongarch.c
+++ b/src/gcc/config/loongarch/loongarch.c
@@ -3661,9 +3661,6 @@ loongarch_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,
 	  fp = FLOAT_TYPE_P (vectype);
 	  mode = TYPE_MODE (vectype);
 	}
-      machine_mode inner_mode = mode;
-      if (VECTOR_MODE_P (mode))
-	inner_mode = GET_MODE_INNER (mode);
 
       switch (subcode)
 	{
@@ -7548,22 +7545,19 @@ loongarch_expand_vec_perm_1 (rtx operands[])
   rtx op0 = operands[1];
   rtx op1 = operands[2];
   rtx mask = operands[3];
-  machine_mode vmode = GET_MODE (target);
   bool one_operand_shuffle = rtx_equal_p (op0, op1);
   rtx t1, t2, t3, t4, t5, t6, vt, vec[32];
   machine_mode mode = GET_MODE (op0);
   machine_mode maskmode = GET_MODE (mask);
-  int w, e, i;
+  int w, i;
 
   /* Number of elements in the vector.  */
   w = GET_MODE_NUNITS (mode);
-  e = GET_MODE_UNIT_SIZE (mode);
 
   if (mode == V4DImode || mode == V4DFmode)
     {
       maskmode = mode = V8SImode;
       w = 8;
-      e = 4;
       t1 = gen_reg_rtx (maskmode);
 
       /* Replicate the low bits of the V4DImode mask into V8SImode:
@@ -7699,14 +7693,12 @@ merge_two:
   vt = GEN_INT (w);
   vt = gen_const_vec_duplicate (maskmode, vt);
   vt = force_reg (maskmode, vt);
-  mask = expand_simple_binop (maskmode, AND, mask, vt,
-			      NULL_RTX, 0, OPTAB_DIRECT);
   if (GET_MODE (target) != mode)
     target = gen_reg_rtx (mode);
   xops[0] = target;
   xops[1] = gen_lowpart (mode, t2);
   xops[2] = gen_lowpart (mode, t1);
-  xops[3] = gen_rtx_EQ (maskmode, mask, vt);
+  xops[3] = gen_rtx_GE (maskmode, mask, vt);
   xops[4] = mask;
   xops[5] = vt;
 
@@ -9330,7 +9322,7 @@ loongarch_expand_vector_extract (rtx target, rtx vec, int elt)
 static void
 emit_reduc_half (rtx dest, rtx src, int i)
 {
-  rtx tem, t, d = dest;
+  rtx tem, d = dest;
   switch (GET_MODE (src))
     {
     case E_V4SFmode:
diff --git a/src/gcc/config/loongarch/lsx.md b/src/gcc/config/loongarch/lsx.md
index 955359ba3..f99099446 100644
--- a/src/gcc/config/loongarch/lsx.md
+++ b/src/gcc/config/loongarch/lsx.md
@@ -1377,8 +1377,8 @@
    (V2DF "V4SI")])
 
 (define_insn "lsx_vreplgr2vr_<lsxfmt_f>"
-  [(set (match_operand:LSX 0 "register_operand" "=f,f")
-	(vec_duplicate:LSX
+  [(set (match_operand:ILSX 0 "register_operand" "=f,f")
+	(vec_duplicate:ILSX
 	  (match_operand:<UNITMODE> 1 "reg_or_0_operand" "r,J")))]
   "ISA_HAS_LSX"
 {
@@ -2200,8 +2200,8 @@
 
 (define_insn "lsx_vreplvei_<lsxfmt_f>_scalar"
   [(set (match_operand:FLSX 0 "register_operand" "=f")
-	(unspec:FLSX [(match_operand:<UNITMODE> 1 "register_operand" "f")]
-		     UNSPEC_LSX_VREPLVEI))]
+	(vec_duplicate:FLSX
+      (match_operand:<UNITMODE> 1 "register_operand" "f")))]
   "ISA_HAS_LSX"
   "vreplvei.<lsxfmt>\t%w0,%w1,0"
   [(set_attr "type" "simd_splat")
@@ -3045,6 +3045,18 @@
    (set_attr "mode" "<MODE>")
    (set_attr "length" "4")])
 
+(define_insn "lsx_vldrepl_<lsxfmt_f>_insn_0"
+  [(set (match_operand:LSX 0 "register_operand" "=f")
+    (vec_duplicate:LSX
+      (mem:<UNITMODE> (match_operand:DI 1 "register_operand" "r"))))]
+  "ISA_HAS_LSX"
+{
+    return "vldrepl.<lsxfmt>\t%w0,%1,0";
+}
+  [(set_attr "type" "simd_load")
+   (set_attr "mode" "<MODE>")
+   (set_attr "length" "4")])
+
 ;; Offset store by sel
 (define_expand "lsx_vstelm_<lsxfmt_f>"
   [(match_operand:LSX 0 "register_operand")
@@ -3073,6 +3085,20 @@
    (set_attr "mode" "<MODE>")
    (set_attr "length" "4")])
 
+;; Offset is "0"
+(define_insn "lsx_vstelm_<lsxfmt_f>_insn_0"
+  [(set (mem:<UNITMODE> (match_operand:DI 0 "register_operand" "r"))
+    (vec_select:<UNITMODE>
+      (match_operand:LSX 1 "register_operand" "f")
+      (parallel [(match_operand:SI 2 "const_<indeximm>_operand")])))]
+  "ISA_HAS_LSX"
+{
+    return "vstelm.<lsxfmt>\t%w1,%0,0,%2";
+}
+  [(set_attr "type" "simd_store")
+   (set_attr "mode" "<MODE>")
+   (set_attr "length" "4")])
+
 (define_expand "lsx_vld"
   [(match_operand:V16QI 0 "register_operand")
    (match_operand 1 "pmode_register_operand")
diff --git a/src/gcc/testsuite/gcc.target/loongarch/lasx-xvldrepl.c b/src/gcc/testsuite/gcc.target/loongarch/lasx-xvldrepl.c
new file mode 100644
index 000000000..f8d1f6759
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/lasx-xvldrepl.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */                         
+/* { dg-options "-O3 -mlasx" } */
+/* { dg-final { scan-assembler-times "xvldrepl.w" 2} } */
+
+#define N 258
+
+float a[N], b[N];
+
+void test() {
+  for(int i = 2; i < N; i++) {
+      a[i] = a[0] * b[i] + a[1];
+  }
+}
diff --git a/src/gcc/testsuite/gcc.target/loongarch/lasx-xvstelm.c b/src/gcc/testsuite/gcc.target/loongarch/lasx-xvstelm.c
new file mode 100644
index 000000000..fad69fad4
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/lasx-xvstelm.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mlasx" } */
+/* { dg-final { scan-assembler-times "xvstelm.w" 8} } */
+
+#define LEN 256
+
+float a[LEN], b[LEN], c[LEN];
+
+void test(){
+    for (int i = 0; i < LEN; i += 2)
+      a[i] = b[i] + c[i];
+}
-- 
2.31.1

