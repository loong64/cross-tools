From d93c2315177d4845346d3e5c7e7123044414d55c Mon Sep 17 00:00:00 2001
From: chenxiaolong <chenxiaolong@loongson.cn>
Date: Thu, 2 Jan 2025 16:12:57 +0800
Subject: [PATCH v1 2/2] LoongArch: Fix vector {x}vfcmp.cond.{s,d} instruction
 computation error.

  For every RTX code for which the LSX/LASX code is different from the
scalar code, the scalar code is correct and the LSX/LASX code is wrong.
Most seriously, the RTX code NE should be mapped to "cneq", not "cne".
Rewrite <x>vfcmp define_insns in simd.md using the same mapping as
scalar fcmp.

This issue has been fixed on gcc14, refer to patch below :
 c5651e9bc057f08bad3297cc2fe3eafffa31c95e

gcc/ChangeLog:

    * config/loongarch/lasx.md: Remove Delete 256-bit vfcmp
    related instruction templates and macro definitions, such as
    lasx_xvfcmp_caf_<flasxfmt>,lasx_xvfcmp_cune_<FLASX:flasxfmt>.                                                                                                                             * config/loongarch/loongarch.c (loongarch_expand_lsx_cmp): Remove
    unneeded special cases.
    * config/loongarch/loongarch.md: Import the simd.md file.
    * config/loongarch/lsx.md: Remove unneeded special cases.
    * config/loongarch/simd.md: New file.
    * testsuite/gcc.target/loongarch/lasx-vcond-2.c: New test.
    * testsuite/gcc.target/loongarch/lsx-vcond-2.c: New test.
    * testsuite/gcc.target/loongarch/vfcmp-d.c: New test.
    * testsuite/gcc.target/loongarch/vfcmp-f.c: New test.
    * testsuite/gcc.target/loongarch/xvfcmp-d.c: New test.
    * testsuite/gcc.target/loongarch/xvfcmp-f.c: New test.

Change-Id: Ic43ec6bfa10527c7e8fa912c4785b0fb4c082d0b
---
 src/gcc/config/loongarch/lasx.md              |  80 -------
 src/gcc/config/loongarch/loongarch.c          |  60 +----
 src/gcc/config/loongarch/loongarch.md         |   9 +-
 src/gcc/config/loongarch/lsx.md               |  98 --------
 src/gcc/config/loongarch/simd.md              | 200 +++++++++++++++++
 .../gcc.target/loongarch/lasx-vcond-2.c       | 177 +++++++++++++++
 .../gcc.target/loongarch/lsx-vcond-2.c        | 177 +++++++++++++++
 .../testsuite/gcc.target/loongarch/vfcmp-d.c  |  28 +++
 .../testsuite/gcc.target/loongarch/vfcmp-f.c  | 212 ++++++++++++++++++
 .../testsuite/gcc.target/loongarch/xvfcmp-d.c |  29 +++
 .../testsuite/gcc.target/loongarch/xvfcmp-f.c |  29 +++
 11 files changed, 855 insertions(+), 244 deletions(-)
 create mode 100644 src/gcc/config/loongarch/simd.md
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/lasx-vcond-2.c
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/lsx-vcond-2.c
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/vfcmp-d.c
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/vfcmp-f.c
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/xvfcmp-d.c
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/xvfcmp-f.c

diff --git a/src/gcc/config/loongarch/lasx.md b/src/gcc/config/loongarch/lasx.md
index f22d0e37a..8da474b62 100644
--- a/src/gcc/config/loongarch/lasx.md
+++ b/src/gcc/config/loongarch/lasx.md
@@ -32,9 +32,7 @@
   UNSPEC_LASX_XVBITREVI
   UNSPEC_LASX_XVBITSET
   UNSPEC_LASX_XVBITSETI
-  UNSPEC_LASX_XVFCMP_CAF
   UNSPEC_LASX_XVFCLASS
-  UNSPEC_LASX_XVFCMP_CUNE
   UNSPEC_LASX_XVFCVT
   UNSPEC_LASX_XVFCVTH
   UNSPEC_LASX_XVFCVTL
@@ -42,17 +40,6 @@
   UNSPEC_LASX_XVFRECIP
   UNSPEC_LASX_XVFRINT
   UNSPEC_LASX_XVFRSQRT
-  UNSPEC_LASX_XVFCMP_SAF
-  UNSPEC_LASX_XVFCMP_SEQ
-  UNSPEC_LASX_XVFCMP_SLE
-  UNSPEC_LASX_XVFCMP_SLT
-  UNSPEC_LASX_XVFCMP_SNE
-  UNSPEC_LASX_XVFCMP_SOR
-  UNSPEC_LASX_XVFCMP_SUEQ
-  UNSPEC_LASX_XVFCMP_SULE
-  UNSPEC_LASX_XVFCMP_SULT
-  UNSPEC_LASX_XVFCMP_SUN
-  UNSPEC_LASX_XVFCMP_SUNE
   UNSPEC_LASX_XVFTINT_S
   UNSPEC_LASX_XVFTINT_U
   UNSPEC_LASX_XVCLO
@@ -209,9 +196,6 @@
 ;; Only used for copy256_{u,s}.w.
 (define_mode_iterator LASX_W    [V8SI V8SF])
 
-;; Only integer modes in LASX.
-(define_mode_iterator ILASX [V4DI V8SI V16HI V32QI])
-
 ;; As ILASX but excludes V32QI.
 (define_mode_iterator ILASX_DWH [V4DI V8SI V16HI])
 
@@ -227,9 +211,6 @@
 ;; Only integer modes smaller than a word.
 (define_mode_iterator ILASX_HB  [V16HI V32QI])
 
-;; Only floating-point modes in LASX.
-(define_mode_iterator FLASX  [V4DF V8SF])
-
 ;; Only used for immediate set shuffle elements instruction.
 (define_mode_iterator LASX_WHB_W [V8SI V16HI V32QI V8SF])
 
@@ -1462,67 +1443,6 @@
   [(set_attr "type" "simd_fclass")
    (set_attr "mode" "<MODE>")])
 
-(define_insn "lasx_xvfcmp_caf_<flasxfmt>"
-  [(set (match_operand:<VIMODE256> 0 "register_operand" "=f")
-	(unspec:<VIMODE256> [(match_operand:FLASX 1 "register_operand" "f")
-			  (match_operand:FLASX 2 "register_operand" "f")]
-			 UNSPEC_LASX_XVFCMP_CAF))]
-  "ISA_HAS_LASX"
-  "xvfcmp.caf.<flasxfmt>\t%u0,%u1,%u2"
-  [(set_attr "type" "simd_fcmp")
-   (set_attr "mode" "<MODE>")])
-
-(define_insn "lasx_xvfcmp_cune_<FLASX:flasxfmt>"
-  [(set (match_operand:<VIMODE256> 0 "register_operand" "=f")
-	(unspec:<VIMODE256> [(match_operand:FLASX 1 "register_operand" "f")
-			  (match_operand:FLASX 2 "register_operand" "f")]
-			 UNSPEC_LASX_XVFCMP_CUNE))]
-  "ISA_HAS_LASX"
-  "xvfcmp.cune.<FLASX:flasxfmt>\t%u0,%u1,%u2"
-  [(set_attr "type" "simd_fcmp")
-   (set_attr "mode" "<MODE>")])
-
-
-
-(define_int_iterator FSC256_UNS [UNSPEC_LASX_XVFCMP_SAF UNSPEC_LASX_XVFCMP_SUN UNSPEC_LASX_XVFCMP_SOR
-			      UNSPEC_LASX_XVFCMP_SEQ UNSPEC_LASX_XVFCMP_SNE UNSPEC_LASX_XVFCMP_SUEQ
-			      UNSPEC_LASX_XVFCMP_SUNE UNSPEC_LASX_XVFCMP_SULE UNSPEC_LASX_XVFCMP_SULT
-			      UNSPEC_LASX_XVFCMP_SLE UNSPEC_LASX_XVFCMP_SLT])
-
-(define_int_attr fsc256
-  [(UNSPEC_LASX_XVFCMP_SAF  "saf")
-   (UNSPEC_LASX_XVFCMP_SUN  "sun")
-   (UNSPEC_LASX_XVFCMP_SOR  "sor")
-   (UNSPEC_LASX_XVFCMP_SEQ  "seq")
-   (UNSPEC_LASX_XVFCMP_SNE  "sne")
-   (UNSPEC_LASX_XVFCMP_SUEQ "sueq")
-   (UNSPEC_LASX_XVFCMP_SUNE "sune")
-   (UNSPEC_LASX_XVFCMP_SULE "sule")
-   (UNSPEC_LASX_XVFCMP_SULT "sult")
-   (UNSPEC_LASX_XVFCMP_SLE  "sle")
-   (UNSPEC_LASX_XVFCMP_SLT  "slt")])
-
-(define_insn "lasx_xvfcmp_<vfcond:fcc>_<FLASX:flasxfmt>"
-  [(set (match_operand:<VIMODE256> 0 "register_operand" "=f")
-	(vfcond:<VIMODE256> (match_operand:FLASX 1 "register_operand" "f")
-		      (match_operand:FLASX 2 "register_operand" "f")))]
-  "ISA_HAS_LASX"
-  "xvfcmp.<vfcond:fcc>.<FLASX:flasxfmt>\t%u0,%u1,%u2"
-  [(set_attr "type" "simd_fcmp")
-   (set_attr "mode" "<MODE>")])
-
-
-(define_insn "lasx_xvfcmp_<fsc256>_<FLASX:flasxfmt>"
-  [(set (match_operand:<VIMODE256> 0 "register_operand" "=f")
-	(unspec:<VIMODE256> [(match_operand:FLASX 1 "register_operand" "f")
-			     (match_operand:FLASX 2 "register_operand" "f")]
-			 FSC256_UNS))]
-  "ISA_HAS_LASX"
-  "xvfcmp.<fsc256>.<FLASX:flasxfmt>\t%u0,%u1,%u2"
-  [(set_attr "type" "simd_fcmp")
-   (set_attr "mode" "<MODE>")])
-
-
 (define_mode_attr fint256
   [(V8SF "v8si")
    (V4DF "v4di")])
diff --git a/src/gcc/config/loongarch/loongarch.c b/src/gcc/config/loongarch/loongarch.c
index ed2286925..ced8b5c74 100644
--- a/src/gcc/config/loongarch/loongarch.c
+++ b/src/gcc/config/loongarch/loongarch.c
@@ -10189,7 +10189,6 @@ static void
 loongarch_expand_lsx_cmp (rtx dest, enum rtx_code cond, rtx op0, rtx op1)
 {
   machine_mode cmp_mode = GET_MODE (op0);
-  int unspec = -1;
   bool negate = false;
 
   switch (cmp_mode)
@@ -10231,66 +10230,9 @@ loongarch_expand_lsx_cmp (rtx dest, enum rtx_code cond, rtx op0, rtx op1)
 
     case E_V4SFmode:
     case E_V2DFmode:
-      switch (cond)
-	{
-	case UNORDERED:
-	case ORDERED:
-	case EQ:
-	case NE:
-	case UNEQ:
-	case UNLE:
-	case UNLT:
-	  break;
-	case LTGT: cond = NE; break;
-	case UNGE: cond = UNLE; std::swap (op0, op1); break;
-	case UNGT: cond = UNLT; std::swap (op0, op1); break;
-	case LE: unspec = UNSPEC_LSX_VFCMP_SLE; break;
-	case LT: unspec = UNSPEC_LSX_VFCMP_SLT; break;
-	case GE: unspec = UNSPEC_LSX_VFCMP_SLE; std::swap (op0, op1); break;
-	case GT: unspec = UNSPEC_LSX_VFCMP_SLT; std::swap (op0, op1); break;
-	default:
-	  gcc_unreachable ();
-	}
-      if (unspec < 0)
-	loongarch_emit_binary (cond, dest, op0, op1);
-      else
-	{
-	  rtx x = gen_rtx_UNSPEC (GET_MODE (dest),
-				  gen_rtvec (2, op0, op1), unspec);
-	  emit_insn (gen_rtx_SET (dest, x));
-	}
-      break;
-
     case E_V8SFmode:
     case E_V4DFmode:
-      switch (cond)
-	{
-	case UNORDERED:
-	case ORDERED:
-	case EQ:
-	case NE:
-	case UNEQ:
-	case UNLE:
-	case UNLT:
-	  break;
-	case LTGT: cond = NE; break;
-	case UNGE: cond = UNLE; std::swap (op0, op1); break;
-	case UNGT: cond = UNLT; std::swap (op0, op1); break;
-	case LE: unspec = UNSPEC_LASX_XVFCMP_SLE; break;
-	case LT: unspec = UNSPEC_LASX_XVFCMP_SLT; break;
-	case GE: unspec = UNSPEC_LASX_XVFCMP_SLE; std::swap (op0, op1); break;
-	case GT: unspec = UNSPEC_LASX_XVFCMP_SLT; std::swap (op0, op1); break;
-	default:
-	  gcc_unreachable ();
-	}
-      if (unspec < 0)
-	loongarch_emit_binary (cond, dest, op0, op1);
-      else
-	{
-	  rtx x = gen_rtx_UNSPEC (GET_MODE (dest),
-				  gen_rtvec (2, op0, op1), unspec);
-	  emit_insn (gen_rtx_SET (dest, x));
-	}
+        loongarch_emit_binary (cond, dest, op0, op1);
       break;
 
     default:
diff --git a/src/gcc/config/loongarch/loongarch.md b/src/gcc/config/loongarch/loongarch.md
index 3e9f293a8..ee960791d 100644
--- a/src/gcc/config/loongarch/loongarch.md
+++ b/src/gcc/config/loongarch/loongarch.md
@@ -3736,14 +3736,9 @@
 (include "generic.md")
 (include "la464.md")
 
-; The LoongArch SX Instructions.
-(include "lsx.md")
+;; The LoongArch SIMD Instructions.
+(include "simd.md")
 
-; The MSA2.0 Instructions.
-(include "lsx2.md")
-
-; The LoongArch ASX Instructions.
-(include "lasx.md")
 
 (define_c_enum "unspec" [
   UNSPEC_ADDRESS_FIRST
diff --git a/src/gcc/config/loongarch/lsx.md b/src/gcc/config/loongarch/lsx.md
index 1f2966a69..604562f56 100644
--- a/src/gcc/config/loongarch/lsx.md
+++ b/src/gcc/config/loongarch/lsx.md
@@ -34,9 +34,7 @@
   UNSPEC_LSX_VBITSETI
   UNSPEC_LSX_BRANCH_V
   UNSPEC_LSX_BRANCH
-  UNSPEC_LSX_VFCMP_CAF
   UNSPEC_LSX_VFCLASS
-  UNSPEC_LSX_VFCMP_CUNE
   UNSPEC_LSX_VFCVT
   UNSPEC_LSX_VFCVTH
   UNSPEC_LSX_VFCVTL
@@ -44,17 +42,6 @@
   UNSPEC_LSX_VFRECIP
   UNSPEC_LSX_VFRINT
   UNSPEC_LSX_VFRSQRT
-  UNSPEC_LSX_VFCMP_SAF
-  UNSPEC_LSX_VFCMP_SEQ
-  UNSPEC_LSX_VFCMP_SLE
-  UNSPEC_LSX_VFCMP_SLT
-  UNSPEC_LSX_VFCMP_SNE
-  UNSPEC_LSX_VFCMP_SOR
-  UNSPEC_LSX_VFCMP_SUEQ
-  UNSPEC_LSX_VFCMP_SULE
-  UNSPEC_LSX_VFCMP_SULT
-  UNSPEC_LSX_VFCMP_SUN
-  UNSPEC_LSX_VFCMP_SUNE
   UNSPEC_LSX_VFTINT_S
   UNSPEC_LSX_VFTINT_U
   UNSPEC_LSX_VCLO
@@ -164,9 +151,6 @@
 ;; Only used for copy_{u,s}.w.
 (define_mode_iterator LSX_W    [V4SI V4SF])
 
-;; Only integer modes.
-(define_mode_iterator ILSX     [V2DI V4SI V8HI V16QI])
-
 ;; As ILSX but excludes V16QI.
 (define_mode_iterator ILSX_DWH [V2DI V4SI V8HI])
 
@@ -185,21 +169,9 @@
 ;;;; Only integer modes for fixed-point madd_q/maddr_q.
 ;;(define_mode_iterator ILSX_WH  [V4SI V8HI])
 
-;; Only floating-point modes.
-(define_mode_iterator FLSX     [V2DF V4SF])
-
 ;; Only used for immediate set shuffle elements instruction.
 (define_mode_iterator LSX_WHB_W [V4SI V8HI V16QI V4SF])
 
-;; The attribute gives the integer vector mode with same size.
-(define_mode_attr VIMODE
-  [(V2DF "V2DI")
-   (V4SF "V4SI")
-   (V2DI "V2DI")
-   (V4SI "V4SI")
-   (V8HI "V8HI")
-   (V16QI "V16QI")])
-
 ;; The attribute gives half modes for vector modes.
 (define_mode_attr VHMODE
   [(V8HI "V16QI")
@@ -1337,76 +1309,6 @@
   [(set_attr "type" "simd_fclass")
    (set_attr "mode" "<MODE>")])
 
-(define_insn "lsx_vfcmp_caf_<flsxfmt>"
-  [(set (match_operand:<VIMODE> 0 "register_operand" "=f")
-	(unspec:<VIMODE> [(match_operand:FLSX 1 "register_operand" "f")
-			  (match_operand:FLSX 2 "register_operand" "f")]
-			 UNSPEC_LSX_VFCMP_CAF))]
-  "ISA_HAS_LSX"
-  "vfcmp.caf.<flsxfmt>\t%w0,%w1,%w2"
-  [(set_attr "type" "simd_fcmp")
-   (set_attr "mode" "<MODE>")])
-
-(define_insn "lsx_vfcmp_cune_<FLSX:flsxfmt>"
-  [(set (match_operand:<VIMODE> 0 "register_operand" "=f")
-	(unspec:<VIMODE> [(match_operand:FLSX 1 "register_operand" "f")
-			  (match_operand:FLSX 2 "register_operand" "f")]
-			 UNSPEC_LSX_VFCMP_CUNE))]
-  "ISA_HAS_LSX"
-  "vfcmp.cune.<FLSX:flsxfmt>\t%w0,%w1,%w2"
-  [(set_attr "type" "simd_fcmp")
-   (set_attr "mode" "<MODE>")])
-
-(define_code_iterator vfcond [unordered ordered eq ne le lt uneq unle unlt])
-
-(define_code_attr fcc
-  [(unordered "cun")
-   (ordered   "cor")
-   (eq        "ceq")
-   (ne        "cne")
-   (uneq      "cueq")
-   (unle      "cule")
-   (unlt      "cult")
-   (le        "cle")
-   (lt        "clt")])
-
-(define_int_iterator FSC_UNS [UNSPEC_LSX_VFCMP_SAF UNSPEC_LSX_VFCMP_SUN UNSPEC_LSX_VFCMP_SOR
-			      UNSPEC_LSX_VFCMP_SEQ UNSPEC_LSX_VFCMP_SNE UNSPEC_LSX_VFCMP_SUEQ
-			      UNSPEC_LSX_VFCMP_SUNE UNSPEC_LSX_VFCMP_SULE UNSPEC_LSX_VFCMP_SULT
-			      UNSPEC_LSX_VFCMP_SLE UNSPEC_LSX_VFCMP_SLT])
-
-(define_int_attr fsc
-  [(UNSPEC_LSX_VFCMP_SAF  "saf")
-   (UNSPEC_LSX_VFCMP_SUN  "sun")
-   (UNSPEC_LSX_VFCMP_SOR  "sor")
-   (UNSPEC_LSX_VFCMP_SEQ  "seq")
-   (UNSPEC_LSX_VFCMP_SNE  "sne")
-   (UNSPEC_LSX_VFCMP_SUEQ "sueq")
-   (UNSPEC_LSX_VFCMP_SUNE "sune")
-   (UNSPEC_LSX_VFCMP_SULE "sule")
-   (UNSPEC_LSX_VFCMP_SULT "sult")
-   (UNSPEC_LSX_VFCMP_SLE  "sle")
-   (UNSPEC_LSX_VFCMP_SLT  "slt")])
-
-(define_insn "lsx_vfcmp_<vfcond:fcc>_<FLSX:flsxfmt>"
-  [(set (match_operand:<VIMODE> 0 "register_operand" "=f")
-	(vfcond:<VIMODE> (match_operand:FLSX 1 "register_operand" "f")
-		      (match_operand:FLSX 2 "register_operand" "f")))]
-  "ISA_HAS_LSX"
-  "vfcmp.<vfcond:fcc>.<FLSX:flsxfmt>\t%w0,%w1,%w2"
-  [(set_attr "type" "simd_fcmp")
-   (set_attr "mode" "<MODE>")])
-
-(define_insn "lsx_vfcmp_<fsc>_<FLSX:flsxfmt>"
-  [(set (match_operand:<VIMODE> 0 "register_operand" "=f")
-	(unspec:<VIMODE> [(match_operand:FLSX 1 "register_operand" "f")
-			   (match_operand:FLSX 2 "register_operand" "f")]
-			 FSC_UNS))]
-  "ISA_HAS_LSX"
-  "vfcmp.<fsc>.<FLSX:flsxfmt>\t%w0,%w1,%w2"
-  [(set_attr "type" "simd_fcmp")
-   (set_attr "mode" "<MODE>")])
-
 (define_mode_attr fint
   [(V4SF "v4si")
    (V2DF "v2di")])
diff --git a/src/gcc/config/loongarch/simd.md b/src/gcc/config/loongarch/simd.md
new file mode 100644
index 000000000..b815ea71a
--- /dev/null
+++ b/src/gcc/config/loongarch/simd.md
@@ -0,0 +1,200 @@
+;; Machine Description for LoongArch SIMD instructions for GNU compiler.
+;; Copyright (C) 2023 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; Integer modes supported by LSX.
+(define_mode_iterator ILSX    [V2DI V4SI V8HI V16QI])
+
+;; Integer modes supported by LASX.
+(define_mode_iterator ILASX   [V4DI V8SI V16HI V32QI])
+
+;; FP modes supported by LSX
+(define_mode_iterator FLSX    [V2DF V4SF])
+
+;; FP modes supported by LASX
+(define_mode_iterator FLASX   [V4DF V8SF])
+
+;; All FP modes available
+(define_mode_iterator FVEC     [(V2DF "ISA_HAS_LSX")
+				(V4SF "ISA_HAS_LSX")
+				(V4DF "ISA_HAS_LASX")
+				(V8SF "ISA_HAS_LASX")])
+
+;; Modifier for vector register, "w" for LSX modes, "u" for LASX modes.
+(define_mode_attr wu   [(V2DI "w") (V4SI "w") (V8HI "w") (V16QI "w")
+			(V2DF "w") (V4SF "w")
+			(V4DI "u") (V8SI "u") (V16HI "u") (V32QI "u")
+			(V4DF "u") (V8SF "u")])
+
+;; define_insn name prefix, "lsx" or "lasx"
+(define_mode_attr simd_isa
+  [(V2DI "lsx") (V4SI "lsx") (V8HI "lsx") (V16QI "lsx")
+   (V2DF "lsx") (V4SF "lsx")
+   (V4DI "lasx") (V8SI "lasx") (V16HI "lasx") (V32QI "lasx")
+   (V4DF "lasx") (V8SF "lasx")])
+
+;; Integer vector modes with the same length and unit size as a mode.
+(define_mode_attr VIMODE   [(V2DI "V2DI") (V4SI "V4SI")
+			    (V8HI "V8HI") (V16QI "V16QI")
+			    (V2DF "V2DI") (V4SF "V4SI")
+			    (V4DI "V4DI") (V8SI "V8SI")
+			    (V16HI "V16HI") (V32QI "V32QI")
+			    (V4DF "V4DI") (V8SF "V8SI")])
+
+;; Suffix for LSX or LASX instructions.
+(define_mode_attr simdfmt  [(V2DF "d") (V4DF "d")
+			    (V4SF "s") (V8SF "s")
+			    (V2DI "d") (V4DI "d")
+			    (V4SI "w") (V8SI "w")
+			    (V8HI "h") (V16HI "h")
+			    (V16QI "b") (V32QI "b")])
+
+;; Mnemonic prefix, "x" for LASX modes.
+(define_mode_attr x    [(V2DI "") (V4SI "") (V8HI "") (V16QI "")
+			(V2DF "") (V4SF "")
+			(V4DI "x") (V8SI "x") (V16HI "x") (V32QI "x")
+			(V4DF "x") (V8SF "x")])
+
+;; <x>vfcmp.*.{s/d} with defined RTX code
+;; There are no fcmp.{sugt/suge/cgt/cge}.{s/d} menmonics in GAS, so we have
+;; to reverse the operands ourselves :(.
+(define_code_iterator fcond_simd [unordered uneq unlt unle eq lt le
+				    ordered ltgt ne])
+(define_insn "<simd_isa>_<x>vfcmp_<fcond>_<simdfmt>"
+  [(set (match_operand:<VIMODE> 0 "register_operand" "=f")
+       (fcond_simd:<VIMODE>
+	(match_operand:FVEC 1 "register_operand" "f")
+	(match_operand:FVEC 2 "register_operand" "f")))]
+  ""
+  "<x>vfcmp.<fcond>.<simdfmt>\t%<wu>0,%<wu>1,%<wu>2"
+  [(set_attr "type" "simd_fcmp")
+   (set_attr "mode" "<MODE>")])
+
+;; There are no fcmp.{sge/sgt/cuge/cugt}.{s/d} menmonics in GAS, so we have
+;; to reverse the operands ourselves.
+(define_code_iterator fcond_simd_rev [ge gt unge ungt])
+
+(define_code_attr fcond_rev_asm
+    [(ge         "sle")
+    (gt         "slt")
+    (unge       "cule")
+    (ungt       "cult")])
+
+(define_insn "<simd_isa>_<x>vfcmp_<fcond>_<simdfmt>"
+  [(set (match_operand:<VIMODE> 0 "register_operand" "=f")
+       (fcond_simd_rev:<VIMODE>
+	(match_operand:FVEC 1 "register_operand" "f")
+	(match_operand:FVEC 2 "register_operand" "f")))]
+  ""
+  "<x>vfcmp.<fcond_rev_asm>.<simdfmt>\t%<wu>0,%<wu>2,%<wu>1";
+  [(set_attr "type" "simd_fcmp")
+   (set_attr "mode" "<MODE>")])
+
+;; <x>vfcmp.*.{s/d} without defined RTX code, but with defined RTX code for
+;; its inverse.  Again, there are no fcmp.{sugt/suge/cgt/cge}.{s/d}
+;; menmonics in GAS, so we have to reverse the operands ourselves.
+(define_code_iterator fcond_inv [ge gt unge ungt])
+(define_code_iterator fcond_inv_rev [le lt unle unlt])
+(define_code_attr fcond_inv
+    [(ge         "sult")
+    (gt         "sule")
+    (unge       "clt")
+    (ungt       "cle")
+    (le         "sugt")
+    (lt         "suge")
+    (unle       "cgt")
+    (unlt       "cge")])
+(define_code_attr fcond_inv_rev_asm
+    [(le         "sult")
+    (lt         "sule")
+    (unle       "clt")
+    (unlt       "cle")])
+
+(define_insn "<simd_isa>_<x>vfcmp_<fcond_inv>_<simdfmt>"
+  [(set (match_operand:<VIMODE> 0 "register_operand" "=f")
+       (not:<VIMODE>
+	    (fcond_inv:<VIMODE>
+	      (match_operand:FVEC 1 "register_operand" "f")
+	      (match_operand:FVEC 2 "register_operand" "f"))))]
+  ""
+  "<x>vfcmp.<fcond_inv>.<simdfmt>\t%<wu>0,%<wu>1,%<wu>2"
+  [(set_attr "type" "simd_fcmp")
+   (set_attr "mode" "<MODE>")])
+
+(define_insn "<simd_isa>_<x>vfcmp_<fcond_inv>_<simdfmt>"
+  [(set (match_operand:<VIMODE> 0 "register_operand" "=f")
+       (not:<VIMODE>
+	(fcond_inv_rev:<VIMODE>
+	    (match_operand:FVEC 1 "register_operand" "f")
+	    (match_operand:FVEC 2 "register_operand" "f"))))]
+  ""
+  "<x>vfcmp.<fcond_inv_rev_asm>.<simdfmt>\t%<wu>0,%<wu>2,%<wu>1"
+  [(set_attr "type" "simd_fcmp")
+   (set_attr "mode" "<MODE>")])
+
+;; <x>vfcmp.*.{s/d} instructions only as instrinsics
+(define_c_enum "unspec"
+  [UNSPEC_SIMD_FCMP_CAF
+   UNSPEC_SIMD_FCMP_SAF
+   UNSPEC_SIMD_FCMP_SEQ
+   UNSPEC_SIMD_FCMP_SUN
+   UNSPEC_SIMD_FCMP_SUEQ
+   UNSPEC_SIMD_FCMP_CNE
+   UNSPEC_SIMD_FCMP_SOR
+   UNSPEC_SIMD_FCMP_SUNE])
+
+
+(define_int_iterator SIMD_FCMP
+  [UNSPEC_SIMD_FCMP_CAF
+   UNSPEC_SIMD_FCMP_SAF
+   UNSPEC_SIMD_FCMP_SEQ
+   UNSPEC_SIMD_FCMP_SUN
+   UNSPEC_SIMD_FCMP_SUEQ
+   UNSPEC_SIMD_FCMP_CNE
+   UNSPEC_SIMD_FCMP_SOR
+   UNSPEC_SIMD_FCMP_SUNE])
+
+(define_int_attr fcond_unspec
+  [(UNSPEC_SIMD_FCMP_CAF       "caf")
+   (UNSPEC_SIMD_FCMP_SAF       "saf")
+   (UNSPEC_SIMD_FCMP_SEQ       "seq")
+   (UNSPEC_SIMD_FCMP_SUN       "sun")
+   (UNSPEC_SIMD_FCMP_SUEQ      "sueq")
+   (UNSPEC_SIMD_FCMP_CNE       "cne")
+   (UNSPEC_SIMD_FCMP_SOR       "sor")
+   (UNSPEC_SIMD_FCMP_SUNE      "sune")])
+
+(define_insn "<simd_isa>_<x>vfcmp_<fcond_unspec>_<simdfmt>"
+  [(set (match_operand:<VIMODE> 0 "register_operand" "=f")
+       (unspec:<VIMODE> [(match_operand:FVEC 1 "register_operand" "f")
+			(match_operand:FVEC 2 "register_operand" "f")]
+			    SIMD_FCMP))]
+  ""
+  "<x>vfcmp.<fcond_unspec>.<simdfmt>\t%<wu>0,%<wu>1,%<wu>2"
+  [(set_attr "type" "simd_fcmp")
+   (set_attr "mode" "<MODE>")])
+
+; The LoongArch SX Instructions.
+ (include "lsx.md")
+
+
+; The LoongArch ASX Instructions.
+ (include "lasx.md")
+
+; The MSA2.0 Instructions.
+(include "lsx2.md")
diff --git a/src/gcc/testsuite/gcc.target/loongarch/lasx-vcond-2.c b/src/gcc/testsuite/gcc.target/loongarch/lasx-vcond-2.c
new file mode 100644
index 000000000..d51df153b
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/lasx-vcond-2.c
@@ -0,0 +1,177 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops  -mlasx" } */
+
+#include <stdint-gcc.h>
+
+#define eq(A, B) ((A) == (B))
+#define ne(A, B) ((A) != (B))
+#define olt(A, B) ((A) < (B))
+#define ole(A, B) ((A) <= (B))
+#define oge(A, B) ((A) >= (B))
+#define ogt(A, B) ((A) > (B))
+#define ordered(A, B) (!__builtin_isunordered (A, B))
+#define unordered(A, B) (__builtin_isunordered (A, B))
+#define ueq(A, B) (!__builtin_islessgreater (A, B))
+#define ult(A, B) (__builtin_isless (A, B))
+#define ule(A, B) (__builtin_islessequal (A, B))
+#define uge(A, B) (__builtin_isgreaterequal (A, B))
+#define ugt(A, B) (__builtin_isgreater (A, B))
+#define nueq(A, B) (__builtin_islessgreater (A, B))
+#define nult(A, B) (!__builtin_isless (A, B))
+#define nule(A, B) (!__builtin_islessequal (A, B))
+#define nuge(A, B) (!__builtin_isgreaterequal (A, B))
+#define nugt(A, B) (!__builtin_isgreater (A, B))
+
+#define TEST_LOOP(TYPE1, TYPE2, CMP)				\
+  void __attribute__ ((noinline, noclone))			\
+  test_##TYPE1##_##TYPE2##_##CMP##_var (TYPE1 *restrict dest,	\
+					TYPE1 *restrict src,	\
+					TYPE1 fallback,		\
+					TYPE2 *restrict a,	\
+					TYPE2 *restrict b,	\
+					int count)		\
+  {								\
+    for (int i = 0; i < count; ++i)				\
+      {\
+        TYPE2 aval = a[i]; \
+        TYPE2 bval = b[i]; \
+        TYPE1 srcval = src[i]; \
+        dest[i] = CMP (aval, bval) ? srcval : fallback;		\
+      }\
+  }
+
+#define TEST_CMP(CMP) \
+  TEST_LOOP (int32_t, float, CMP) \
+  TEST_LOOP (uint32_t, float, CMP) \
+  TEST_LOOP (float, float, CMP) \
+  TEST_LOOP (int64_t, double, CMP) \
+  TEST_LOOP (uint64_t, double, CMP) \
+  TEST_LOOP (double, double, CMP)
+
+TEST_CMP (eq)
+TEST_CMP (ne)
+TEST_CMP (olt)
+TEST_CMP (ole)
+TEST_CMP (oge)
+TEST_CMP (ogt)
+TEST_CMP (ordered)
+TEST_CMP (unordered)
+TEST_CMP (ueq)
+TEST_CMP (ult)
+TEST_CMP (ule)
+TEST_CMP (uge)
+TEST_CMP (ugt)
+TEST_CMP (nueq)
+TEST_CMP (nult)
+TEST_CMP (nule)
+TEST_CMP (nuge)
+TEST_CMP (nugt)
+
+/* { dg-final { scan-assembler "test_int32_t_float_eq_var:.*xvfcmp\\.ceq\\.s.*test_int32_t_float_eq_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_eq_var:.*xvfcmp\\.ceq\\.s.*test_uint32_t_float_eq_var" } } */
+/* { dg-final { scan-assembler "test_float_float_eq_var:.*xvfcmp\\.ceq\\.s.*test_float_float_eq_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_eq_var:.*xvfcmp\\.ceq\\.d.*test_int64_t_double_eq_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_eq_var:.*xvfcmp\\.ceq\\.d.*test_uint64_t_double_eq_var" } } */
+/* { dg-final { scan-assembler "test_double_double_eq_var:.*xvfcmp\\.ceq\\.d.*test_double_double_eq_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ne_var:.*xvfcmp.cune.s.*test_int32_t_float_ne_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ne_var:.*xvfcmp\\.cune\\.s.*test_uint32_t_float_ne_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ne_var:.*xvfcmp\\.cune\\.s.*test_float_float_ne_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ne_var:.*xvfcmp\\.cune\\.d.*test_int64_t_double_ne_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ne_var:.*xvfcmp.cune.d.*test_uint64_t_double_ne_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ne_var:.*xvfcmp\\.cune\\.d.*test_double_double_ne_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_olt_var:.*xvfcmp\\.slt\\.s.*test_int32_t_float_olt_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_olt_var:.*xvfcmp\\.slt\\.s.*test_uint32_t_float_olt_var" } } */
+/* { dg-final { scan-assembler "test_float_float_olt_var:.*xvfcmp\\.slt\\.s.*test_float_float_olt_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_olt_var:.*xvfcmp\\.slt\\.d.*test_int64_t_double_olt_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_olt_var:.*xvfcmp\\.slt\\.d.*test_uint64_t_double_olt_var" } } */
+/* { dg-final { scan-assembler "test_double_double_olt_var:.*xvfcmp\\.slt\\.d.*test_double_double_olt_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ole_var:.*xvfcmp\\.sle\\.s.*test_int32_t_float_ole_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ole_var:.*xvfcmp\\.sle\\.s.*test_uint32_t_float_ole_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ole_var:.*xvfcmp\\.sle\\.s.*test_float_float_ole_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ole_var:.*xvfcmp\\.sle\\.d.*test_int64_t_double_ole_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ole_var:.*xvfcmp\\.sle\\.d.*test_uint64_t_double_ole_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ole_var:.*xvfcmp\\.sle\\.d.*test_double_double_ole_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_oge_var:.*xvfcmp\\.sle\\.s.*test_int32_t_float_oge_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_oge_var:.*xvfcmp\\.sle\\.s.*test_uint32_t_float_oge_var" } } */
+/* { dg-final { scan-assembler "test_float_float_oge_var:.*xvfcmp\\.sle\\.s.*test_float_float_oge_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_oge_var:.*xvfcmp\\.sle\\.d.*test_int64_t_double_oge_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_oge_var:.*xvfcmp\\.sle\\.d.*test_uint64_t_double_oge_var" } } */
+/* { dg-final { scan-assembler "test_double_double_oge_var:.*xvfcmp\\.sle\\.d.*test_double_double_oge_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ogt_var:.*xvfcmp\\.slt\\.s.*test_int32_t_float_ogt_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ogt_var:.*xvfcmp\\.slt\\.s.*test_uint32_t_float_ogt_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ogt_var:.*xvfcmp\\.slt\\.s.*test_float_float_ogt_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ogt_var:.*xvfcmp\\.slt\\.d.*test_int64_t_double_ogt_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ogt_var:.*xvfcmp\\.slt\\.d.*test_uint64_t_double_ogt_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ogt_var:.*xvfcmp\\.slt\\.d.*test_double_double_ogt_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ordered_var:.*xvfcmp\\.cor\\.s.*test_int32_t_float_ordered_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ordered_var:.*xvfcmp\\.cor\\.s.*test_uint32_t_float_ordered_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ordered_var:.*xvfcmp\\.cor\\.s.*test_float_float_ordered_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ordered_var:.*xvfcmp\\.cor\\.d.*test_int64_t_double_ordered_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ordered_var:.*xvfcmp\\.cor\\.d.*test_uint64_t_double_ordered_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ordered_var:.*xvfcmp\\.cor\\.d.*test_double_double_ordered_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_unordered_var:.*xvfcmp\\.cun\\.s.*test_int32_t_float_unordered_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_unordered_var:.*xvfcmp\\.cun\\.s.*test_uint32_t_float_unordered_var" } } */
+/* { dg-final { scan-assembler "test_float_float_unordered_var:.*xvfcmp\\.cun\\.s.*test_float_float_unordered_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_unordered_var:.*xvfcmp\\.cun\\.d.*test_int64_t_double_unordered_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_unordered_var:.*xvfcmp\\.cun\\.d.*test_uint64_t_double_unordered_var" } } */
+/* { dg-final { scan-assembler "test_double_double_unordered_var:.*xvfcmp\\.cun\\.d.*test_double_double_unordered_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ueq_var:.*xvfcmp\\.cueq\\.s.*test_int32_t_float_ueq_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ueq_var:.*xvfcmp\\.cueq\\.s.*test_uint32_t_float_ueq_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ueq_var:.*xvfcmp\\.cueq\\.s.*test_float_float_ueq_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ueq_var:.*xvfcmp\\.cueq\\.d.*test_int64_t_double_ueq_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ueq_var:.*xvfcmp\\.cueq\\.d.*test_uint64_t_double_ueq_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ueq_var:.*xvfcmp\\.cueq\\.d.*test_double_double_ueq_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ult_var:.*xvfcmp\\.cule\\.s.*test_int32_t_float_ult_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ult_var:.*xvfcmp\\.cule\\.s.*test_uint32_t_float_ult_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ult_var:.*xvfcmp\\.cule\\.s.*test_float_float_ult_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ult_var:.*xvfcmp\\.cule\\.d.*test_int64_t_double_ult_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ult_var:.*xvfcmp\\.cule\\.d.*test_uint64_t_double_ult_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ult_var:.*xvfcmp\\.cule\\.d.*test_double_double_ult_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ule_var:.*xvfcmp\\.cult\\.s.*test_int32_t_float_ule_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ule_var:.*xvfcmp\\.cult\\.s.*test_uint32_t_float_ule_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ule_var:.*xvfcmp\\.cult\\.s.*test_float_float_ule_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ule_var:.*xvfcmp\\.cult\\.d.*test_int64_t_double_ule_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ule_var:.*xvfcmp\\.cult\\.d.*test_uint64_t_double_ule_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ule_var:.*xvfcmp\\.cult\\.d.*test_double_double_ule_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_uge_var:.*xvfcmp\\.cult\\.s.*test_int32_t_float_uge_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_uge_var:.*xvfcmp\\.cult\\.s.*test_uint32_t_float_uge_var" } } */
+/* { dg-final { scan-assembler "test_float_float_uge_var:.*xvfcmp\\.cult\\.s.*test_float_float_uge_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_uge_var:.*xvfcmp\\.cult\\.d.*test_int64_t_double_uge_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_uge_var:.*xvfcmp\\.cult\\.d.*test_uint64_t_double_uge_var" } } */
+/* { dg-final { scan-assembler "test_double_double_uge_var:.*xvfcmp\\.cult\\.d.*test_double_double_uge_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ugt_var:.*xvfcmp\\.cule\\.s.*test_int32_t_float_ugt_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ugt_var:.*xvfcmp\\.cule\\.s.*test_uint32_t_float_ugt_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ugt_var:.*xvfcmp\\.cule\\.s.*test_float_float_ugt_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ugt_var:.*xvfcmp\\.cule\\.d.*test_int64_t_double_ugt_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ugt_var:.*xvfcmp\\.cule\\.d.*test_uint64_t_double_ugt_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ugt_var:.*xvfcmp\\.cule\\.d.*test_double_double_ugt_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nueq_var:.*xvfcmp\\.cueq\\.s.*test_int32_t_float_nueq_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nueq_var:.*xvfcmp\\.cueq\\.s.*test_uint32_t_float_nueq_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nueq_var:.*xvfcmp\\.cueq\\.s.*test_float_float_nueq_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nueq_var:.*xvfcmp\\.cueq\\.d.*test_int64_t_double_nueq_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nueq_var:.*xvfcmp\\.cueq\\.d.*test_uint64_t_double_nueq_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nueq_var:.*xvfcmp\\.cueq\\.d.*test_double_double_nueq_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nult_var:.*xvfcmp\\.cule\\.s.*test_int32_t_float_nult_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nult_var:.*xvfcmp\\.cule\\.s.*test_uint32_t_float_nult_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nult_var:.*xvfcmp\\.cule\\.s.*test_float_float_nult_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nult_var:.*xvfcmp\\.cule\\.d.*test_int64_t_double_nult_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nult_var:.*xvfcmp\\.cule\\.d.*test_uint64_t_double_nult_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nult_var:.*xvfcmp\\.cule\\.d.*test_double_double_nult_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nule_var:.*xvfcmp\\.cult\\.s.*test_int32_t_float_nule_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nule_var:.*xvfcmp\\.cult\\.s.*test_uint32_t_float_nule_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nule_var:.*xvfcmp\\.cult\\.s.*test_float_float_nule_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nule_var:.*xvfcmp\\.cult\\.d.*test_int64_t_double_nule_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nule_var:.*xvfcmp\\.cult\\.d.*test_uint64_t_double_nule_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nule_var:.*xvfcmp\\.cult\\.d.*test_double_double_nule_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nuge_var:.*xvfcmp\\.cult\\.s.*test_int32_t_float_nuge_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nuge_var:.*xvfcmp\\.cult\\.s.*test_uint32_t_float_nuge_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nuge_var:.*xvfcmp\\.cult\\.s.*test_float_float_nuge_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nuge_var:.*xvfcmp\\.cult\\.d.*test_int64_t_double_nuge_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nuge_var:.*xvfcmp\\.cult\\.d.*test_uint64_t_double_nuge_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nuge_var:.*xvfcmp\\.cult\\.d.*test_double_double_nuge_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nugt_var:.*xvfcmp\\.cule\\.s.*test_int32_t_float_nugt_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nugt_var:.*xvfcmp\\.cule\\.s.*test_uint32_t_float_nugt_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nugt_var:.*xvfcmp\\.cule\\.s.*test_float_float_nugt_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nugt_var:.*xvfcmp\\.cule\\.d.*test_int64_t_double_nugt_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nugt_var:.*xvfcmp\\.cule\\.d.*test_uint64_t_double_nugt_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nugt_var:.*xvfcmp\\.cule\\.d.*test_double_double_nugt_var" } } */
diff --git a/src/gcc/testsuite/gcc.target/loongarch/lsx-vcond-2.c b/src/gcc/testsuite/gcc.target/loongarch/lsx-vcond-2.c
new file mode 100644
index 000000000..b4af1b68d
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/lsx-vcond-2.c
@@ -0,0 +1,177 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-vectorize -fno-vect-cost-model -fno-unroll-loops  -mlsx" } */
+
+#include <stdint-gcc.h>
+
+#define eq(A, B) ((A) == (B))
+#define ne(A, B) ((A) != (B))
+#define olt(A, B) ((A) < (B))
+#define ole(A, B) ((A) <= (B))
+#define oge(A, B) ((A) >= (B))
+#define ogt(A, B) ((A) > (B))
+#define ordered(A, B) (!__builtin_isunordered (A, B))
+#define unordered(A, B) (__builtin_isunordered (A, B))
+#define ueq(A, B) (!__builtin_islessgreater (A, B))
+#define ult(A, B) (__builtin_isless (A, B))
+#define ule(A, B) (__builtin_islessequal (A, B))
+#define uge(A, B) (__builtin_isgreaterequal (A, B))
+#define ugt(A, B) (__builtin_isgreater (A, B))
+#define nueq(A, B) (__builtin_islessgreater (A, B))
+#define nult(A, B) (!__builtin_isless (A, B))
+#define nule(A, B) (!__builtin_islessequal (A, B))
+#define nuge(A, B) (!__builtin_isgreaterequal (A, B))
+#define nugt(A, B) (!__builtin_isgreater (A, B))
+
+#define TEST_LOOP(TYPE1, TYPE2, CMP)				\
+  void __attribute__ ((noinline, noclone))			\
+  test_##TYPE1##_##TYPE2##_##CMP##_var (TYPE1 *restrict dest,	\
+					TYPE1 *restrict src,	\
+					TYPE1 fallback,		\
+					TYPE2 *restrict a,	\
+					TYPE2 *restrict b,	\
+					int count)		\
+  {								\
+    for (int i = 0; i < count; ++i)				\
+      {\
+        TYPE2 aval = a[i]; \
+        TYPE2 bval = b[i]; \
+        TYPE1 srcval = src[i]; \
+        dest[i] = CMP (aval, bval) ? srcval : fallback;		\
+      }\
+  }
+
+#define TEST_CMP(CMP) \
+  TEST_LOOP (int32_t, float, CMP) \
+  TEST_LOOP (uint32_t, float, CMP) \
+  TEST_LOOP (float, float, CMP) \
+  TEST_LOOP (int64_t, double, CMP) \
+  TEST_LOOP (uint64_t, double, CMP) \
+  TEST_LOOP (double, double, CMP)
+
+TEST_CMP (eq)
+TEST_CMP (ne)
+TEST_CMP (olt)
+TEST_CMP (ole)
+TEST_CMP (oge)
+TEST_CMP (ogt)
+TEST_CMP (ordered)
+TEST_CMP (unordered)
+TEST_CMP (ueq)
+TEST_CMP (ult)
+TEST_CMP (ule)
+TEST_CMP (uge)
+TEST_CMP (ugt)
+TEST_CMP (nueq)
+TEST_CMP (nult)
+TEST_CMP (nule)
+TEST_CMP (nuge)
+TEST_CMP (nugt)
+
+/* { dg-final { scan-assembler "test_int32_t_float_eq_var:.*vfcmp\\.ceq\\.s.*test_int32_t_float_eq_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_eq_var:.*vfcmp\\.ceq\\.s.*test_uint32_t_float_eq_var" } } */
+/* { dg-final { scan-assembler "test_float_float_eq_var:.*vfcmp\\.ceq\\.s.*test_float_float_eq_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_eq_var:.*vfcmp\\.ceq\\.d.*test_int64_t_double_eq_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_eq_var:.*vfcmp\\.ceq\\.d.*test_uint64_t_double_eq_var" } } */
+/* { dg-final { scan-assembler "test_double_double_eq_var:.*vfcmp\\.ceq\\.d.*test_double_double_eq_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ne_var:.*vfcmp.cune.s.*test_int32_t_float_ne_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ne_var:.*vfcmp\\.cune\\.s.*test_uint32_t_float_ne_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ne_var:.*vfcmp\\.cune\\.s.*test_float_float_ne_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ne_var:.*vfcmp\\.cune\\.d.*test_int64_t_double_ne_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ne_var:.*vfcmp.cune.d.*test_uint64_t_double_ne_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ne_var:.*vfcmp\\.cune\\.d.*test_double_double_ne_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_olt_var:.*vfcmp\\.slt\\.s.*test_int32_t_float_olt_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_olt_var:.*vfcmp\\.slt\\.s.*test_uint32_t_float_olt_var" } } */
+/* { dg-final { scan-assembler "test_float_float_olt_var:.*vfcmp\\.slt\\.s.*test_float_float_olt_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_olt_var:.*vfcmp\\.slt\\.d.*test_int64_t_double_olt_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_olt_var:.*vfcmp\\.slt\\.d.*test_uint64_t_double_olt_var" } } */
+/* { dg-final { scan-assembler "test_double_double_olt_var:.*vfcmp\\.slt\\.d.*test_double_double_olt_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ole_var:.*vfcmp\\.sle\\.s.*test_int32_t_float_ole_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ole_var:.*vfcmp\\.sle\\.s.*test_uint32_t_float_ole_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ole_var:.*vfcmp\\.sle\\.s.*test_float_float_ole_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ole_var:.*vfcmp\\.sle\\.d.*test_int64_t_double_ole_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ole_var:.*vfcmp\\.sle\\.d.*test_uint64_t_double_ole_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ole_var:.*vfcmp\\.sle\\.d.*test_double_double_ole_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_oge_var:.*vfcmp\\.sle\\.s.*test_int32_t_float_oge_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_oge_var:.*vfcmp\\.sle\\.s.*test_uint32_t_float_oge_var" } } */
+/* { dg-final { scan-assembler "test_float_float_oge_var:.*vfcmp\\.sle\\.s.*test_float_float_oge_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_oge_var:.*vfcmp\\.sle\\.d.*test_int64_t_double_oge_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_oge_var:.*vfcmp\\.sle\\.d.*test_uint64_t_double_oge_var" } } */
+/* { dg-final { scan-assembler "test_double_double_oge_var:.*vfcmp\\.sle\\.d.*test_double_double_oge_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ogt_var:.*vfcmp\\.slt\\.s.*test_int32_t_float_ogt_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ogt_var:.*vfcmp\\.slt\\.s.*test_uint32_t_float_ogt_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ogt_var:.*vfcmp\\.slt\\.s.*test_float_float_ogt_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ogt_var:.*vfcmp\\.slt\\.d.*test_int64_t_double_ogt_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ogt_var:.*vfcmp\\.slt\\.d.*test_uint64_t_double_ogt_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ogt_var:.*vfcmp\\.slt\\.d.*test_double_double_ogt_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ordered_var:.*vfcmp\\.cor\\.s.*test_int32_t_float_ordered_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ordered_var:.*vfcmp\\.cor\\.s.*test_uint32_t_float_ordered_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ordered_var:.*vfcmp\\.cor\\.s.*test_float_float_ordered_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ordered_var:.*vfcmp\\.cor\\.d.*test_int64_t_double_ordered_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ordered_var:.*vfcmp\\.cor\\.d.*test_uint64_t_double_ordered_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ordered_var:.*vfcmp\\.cor\\.d.*test_double_double_ordered_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_unordered_var:.*vfcmp\\.cun\\.s.*test_int32_t_float_unordered_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_unordered_var:.*vfcmp\\.cun\\.s.*test_uint32_t_float_unordered_var" } } */
+/* { dg-final { scan-assembler "test_float_float_unordered_var:.*vfcmp\\.cun\\.s.*test_float_float_unordered_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_unordered_var:.*vfcmp\\.cun\\.d.*test_int64_t_double_unordered_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_unordered_var:.*vfcmp\\.cun\\.d.*test_uint64_t_double_unordered_var" } } */
+/* { dg-final { scan-assembler "test_double_double_unordered_var:.*vfcmp\\.cun\\.d.*test_double_double_unordered_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ueq_var:.*vfcmp\\.cueq\\.s.*test_int32_t_float_ueq_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ueq_var:.*vfcmp\\.cueq\\.s.*test_uint32_t_float_ueq_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ueq_var:.*vfcmp\\.cueq\\.s.*test_float_float_ueq_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ueq_var:.*vfcmp\\.cueq\\.d.*test_int64_t_double_ueq_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ueq_var:.*vfcmp\\.cueq\\.d.*test_uint64_t_double_ueq_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ueq_var:.*vfcmp\\.cueq\\.d.*test_double_double_ueq_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ult_var:.*vfcmp\\.cule\\.s.*test_int32_t_float_ult_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ult_var:.*vfcmp\\.cule\\.s.*test_uint32_t_float_ult_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ult_var:.*vfcmp\\.cule\\.s.*test_float_float_ult_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ult_var:.*vfcmp\\.cule\\.d.*test_int64_t_double_ult_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ult_var:.*vfcmp\\.cule\\.d.*test_uint64_t_double_ult_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ult_var:.*vfcmp\\.cule\\.d.*test_double_double_ult_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ule_var:.*vfcmp\\.cult\\.s.*test_int32_t_float_ule_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ule_var:.*vfcmp\\.cult\\.s.*test_uint32_t_float_ule_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ule_var:.*vfcmp\\.cult\\.s.*test_float_float_ule_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ule_var:.*vfcmp\\.cult\\.d.*test_int64_t_double_ule_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ule_var:.*vfcmp\\.cult\\.d.*test_uint64_t_double_ule_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ule_var:.*vfcmp\\.cult\\.d.*test_double_double_ule_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_uge_var:.*vfcmp\\.cult\\.s.*test_int32_t_float_uge_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_uge_var:.*vfcmp\\.cult\\.s.*test_uint32_t_float_uge_var" } } */
+/* { dg-final { scan-assembler "test_float_float_uge_var:.*vfcmp\\.cult\\.s.*test_float_float_uge_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_uge_var:.*vfcmp\\.cult\\.d.*test_int64_t_double_uge_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_uge_var:.*vfcmp\\.cult\\.d.*test_uint64_t_double_uge_var" } } */
+/* { dg-final { scan-assembler "test_double_double_uge_var:.*vfcmp\\.cult\\.d.*test_double_double_uge_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_ugt_var:.*vfcmp\\.cule\\.s.*test_int32_t_float_ugt_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_ugt_var:.*vfcmp\\.cule\\.s.*test_uint32_t_float_ugt_var" } } */
+/* { dg-final { scan-assembler "test_float_float_ugt_var:.*vfcmp\\.cule\\.s.*test_float_float_ugt_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_ugt_var:.*vfcmp\\.cule\\.d.*test_int64_t_double_ugt_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_ugt_var:.*vfcmp\\.cule\\.d.*test_uint64_t_double_ugt_var" } } */
+/* { dg-final { scan-assembler "test_double_double_ugt_var:.*vfcmp\\.cule\\.d.*test_double_double_ugt_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nueq_var:.*vfcmp\\.cueq\\.s.*test_int32_t_float_nueq_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nueq_var:.*vfcmp\\.cueq\\.s.*test_uint32_t_float_nueq_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nueq_var:.*vfcmp\\.cueq\\.s.*test_float_float_nueq_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nueq_var:.*vfcmp\\.cueq\\.d.*test_int64_t_double_nueq_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nueq_var:.*vfcmp\\.cueq\\.d.*test_uint64_t_double_nueq_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nueq_var:.*vfcmp\\.cueq\\.d.*test_double_double_nueq_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nult_var:.*vfcmp\\.cule\\.s.*test_int32_t_float_nult_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nult_var:.*vfcmp\\.cule\\.s.*test_uint32_t_float_nult_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nult_var:.*vfcmp\\.cule\\.s.*test_float_float_nult_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nult_var:.*vfcmp\\.cule\\.d.*test_int64_t_double_nult_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nult_var:.*vfcmp\\.cule\\.d.*test_uint64_t_double_nult_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nult_var:.*vfcmp\\.cule\\.d.*test_double_double_nult_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nule_var:.*vfcmp\\.cult\\.s.*test_int32_t_float_nule_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nule_var:.*vfcmp\\.cult\\.s.*test_uint32_t_float_nule_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nule_var:.*vfcmp\\.cult\\.s.*test_float_float_nule_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nule_var:.*vfcmp\\.cult\\.d.*test_int64_t_double_nule_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nule_var:.*vfcmp\\.cult\\.d.*test_uint64_t_double_nule_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nule_var:.*vfcmp\\.cult\\.d.*test_double_double_nule_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nuge_var:.*vfcmp\\.cult\\.s.*test_int32_t_float_nuge_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nuge_var:.*vfcmp\\.cult\\.s.*test_uint32_t_float_nuge_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nuge_var:.*vfcmp\\.cult\\.s.*test_float_float_nuge_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nuge_var:.*vfcmp\\.cult\\.d.*test_int64_t_double_nuge_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nuge_var:.*vfcmp\\.cult\\.d.*test_uint64_t_double_nuge_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nuge_var:.*vfcmp\\.cult\\.d.*test_double_double_nuge_var" } } */
+/* { dg-final { scan-assembler "test_int32_t_float_nugt_var:.*vfcmp\\.cule\\.s.*test_int32_t_float_nugt_var" } } */
+/* { dg-final { scan-assembler "test_uint32_t_float_nugt_var:.*vfcmp\\.cule\\.s.*test_uint32_t_float_nugt_var" } } */
+/* { dg-final { scan-assembler "test_float_float_nugt_var:.*vfcmp\\.cule\\.s.*test_float_float_nugt_var" } } */
+/* { dg-final { scan-assembler "test_int64_t_double_nugt_var:.*vfcmp\\.cule\\.d.*test_int64_t_double_nugt_var" } } */
+/* { dg-final { scan-assembler "test_uint64_t_double_nugt_var:.*vfcmp\\.cule\\.d.*test_uint64_t_double_nugt_var" } } */
+/* { dg-final { scan-assembler "test_double_double_nugt_var:.*vfcmp\\.cule\\.d.*test_double_double_nugt_var" } } */
diff --git a/src/gcc/testsuite/gcc.target/loongarch/vfcmp-d.c b/src/gcc/testsuite/gcc.target/loongarch/vfcmp-d.c
new file mode 100644
index 000000000..1c2bae4ba
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/vfcmp-d.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mlsx -fno-vect-cost-model -ftree-vectorize" } */
+/* { dg-final { scan-assembler "compare_quiet_equal:.*vfcmp\\.ceq\\.d.*compare_quiet_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_equal:.*vfcmp\\.cune\\.d.*compare_quiet_not_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater:.*vfcmp\\.slt\\.d.*compare_signaling_greater" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater_equal:.*vfcmp\\.sle\\.d.*compare_signaling_greater_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_less:.*vfcmp\\.slt\\.d.*compare_signaling_less" } } */
+/* { dg-final { scan-assembler "compare_signaling_less_equal:.*vfcmp\\.sle\\.d.*compare_signaling_less_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_not_greater:.*vfcmp\\.sule\\.d.*compare_signaling_not_greater" } } */
+/* { dg-final { scan-assembler "compare_signaling_less_unordered:.*vfcmp\\.sult\\.d.*compare_signaling_less_unordered" } } */
+/* { dg-final { scan-assembler "compare_signaling_not_less:.*vfcmp\\.sule\\.d.*compare_signaling_not_less" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater_unordered:.*vfcmp\\.sult\\.d.*compare_signaling_greater_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_less:.*fcmp\\.cuge\\.d.*compare_quiet_less" } } */
+/* { dg-final { scan-assembler "compare_quiet_less_equal:.*fcmp\\.cugt\\.d.*compare_quiet_less_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater:.*fcmp\\.cule\\.d.*compare_quiet_greater" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater_equal:.*fcmp\\.cult\\.d.*compare_quiet_greater_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_less:.*fcmp\\.cuge\\.d.*compare_quiet_not_less" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater_unordered:.*fcmp\\.cugt\\.d.*compare_quiet_greater_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_greater:.*fcmp\\.cule\\.d.*compare_quiet_not_greater" } } */
+/* { dg-final { scan-assembler "compare_quiet_less_unordered:.*fcmp\\.cult\\.d.*compare_quiet_less_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_unordered:.*fcmp\\.cun\\.d.*compare_quiet_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_ordered:.*fcmp\\.cor\\.d.*compare_quiet_ordered" } } */
+
+#define F double
+#define I long long
+
+#include "vfcmp-f.c"
+
diff --git a/src/gcc/testsuite/gcc.target/loongarch/vfcmp-f.c b/src/gcc/testsuite/gcc.target/loongarch/vfcmp-f.c
new file mode 100644
index 000000000..3882711a8
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/vfcmp-f.c
@@ -0,0 +1,212 @@
+/* Test mapping IEC 60559 operations to SIMD instructions.
+   For details read C23 Annex F.3 and LoongArch Vol. 1 section 3.2.2.1.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -mlsx -fno-vect-cost-model -ftree-vectorize" } */
+/* { dg-final { scan-assembler "compare_quiet_equal:.*vfcmp\\.ceq\\.s.*compare_quiet_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_equal:.*vfcmp\\.cune\\.s.*compare_quiet_not_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater:.*vfcmp\\.slt\\.s.*compare_signaling_greater" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater_equal:.*vfcmp\\.sle\\.s.*compare_signaling_greater_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_less:.*vfcmp\\.slt\\.s.*compare_signaling_less" } } */
+/* { dg-final { scan-assembler "compare_signaling_less_equal:.*vfcmp\\.sle\\.s.*compare_signaling_less_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_not_greater:.*vfcmp\\.sule\\.s.*compare_signaling_not_greater" } } */
+/* { dg-final { scan-assembler "compare_signaling_less_unordered:.*vfcmp\\.sult\\.s.*compare_signaling_less_unordered" } } */
+/* { dg-final { scan-assembler "compare_signaling_not_less:.*vfcmp\\.sule\\.s.*compare_signaling_not_less" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater_unordered:.*vfcmp\\.sult\\.s.*compare_signaling_greater_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_less:.*vfcmp\\.cule\\.s.*compare_quiet_less" } } */
+/* { dg-final { scan-assembler "compare_quiet_less_equal:.*vfcmp\\.cult\\.s.*compare_quiet_less_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater:.*vfcmp\\.cule\\.s.*compare_quiet_greater" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater_equal:.*vfcmp\\.cult\\.s.*compare_quiet_greater_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_less:.*vfcmp\\.cule\\.s.*compare_quiet_not_less" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater_unordered:.*vfcmp\\.cult\\.s.*compare_quiet_greater_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_greater:.*vfcmp\\.cule\\.s.*compare_quiet_not_greater" } } */
+/* { dg-final { scan-assembler "compare_quiet_less_unordered:.*vfcmp\\.cult\\.s.*compare_quiet_less_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_unordered:.*vfcmp\\.cun\\.s.*compare_quiet_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_ordered:.*vfcmp\\.cor\\.s.*compare_quiet_ordered" } } */
+
+#ifndef F
+#define F float
+#endif
+
+#ifndef I
+#define I int
+#endif
+
+#ifndef VL
+#define VL 16
+#endif
+
+typedef F VF __attribute__ ((vector_size (VL)));
+typedef I VI __attribute__ ((vector_size (VL)));
+
+#define ARGS const VF *a, const VF *b, VI *c
+
+void
+compare_quiet_equal (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = (_a == *b);
+}
+
+void
+compare_quiet_not_equal (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = (_a != *b);
+}
+
+void
+compare_signaling_greater (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = (_a > *b);
+}
+
+void
+compare_signaling_greater_equal (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = (_a >= *b);
+}
+
+void
+compare_signaling_less (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = (_a < *b);
+}
+
+void
+compare_signaling_less_equal (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = (_a <= *b);
+}
+
+void
+compare_signaling_not_greater (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = ~(_a > *b);
+}
+
+void
+compare_signaling_less_unordered (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = ~(_a >= *b);
+}
+
+void
+compare_signaling_not_less (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = ~(_a < *b);
+}
+
+void
+compare_signaling_greater_unordered (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  *c = ~(_a <= *b);
+}
+
+void
+compare_quiet_less (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_isless (_a[i], (*b)[i]) ? -1 : 0;
+}
+
+void
+compare_quiet_less_equal (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_islessequal (_a[i], (*b)[i]) ? -1 : 0;
+}
+
+void
+compare_quiet_greater (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_isgreater (_a[i], (*b)[i]) ? -1 : 0;
+}
+
+void
+compare_quiet_greater_equal (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_isgreaterequal (_a[i], (*b)[i]) ? -1 : 0;
+}
+
+void
+compare_quiet_not_less (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_isless (_a[i], (*b)[i]) ? 0 : -1;
+}
+
+void
+compare_quiet_greater_unordered (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_islessequal (_a[i], (*b)[i]) ? 0 : -1;
+}
+
+void
+compare_quiet_not_greater (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_isgreater (_a[i], (*b)[i]) ? 0 : -1;
+}
+
+void
+compare_quiet_less_unordered (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_isgreaterequal (_a[i], (*b)[i]) ? 0 : -1;
+}
+
+void
+compare_quiet_unordered (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_isunordered (_a[i], (*b)[i]) ? -1 : 0;
+}
+
+void
+compare_quiet_ordered (ARGS)
+{
+  VF _a = *a;
+  asm("" ::: "memory");
+  for (int i = 0; i < sizeof (*c) / sizeof ((*c)[0]); i++)
+    (*c)[i] = __builtin_isunordered (_a[i], (*b)[i]) ? 0 : -1;
+}
diff --git a/src/gcc/testsuite/gcc.target/loongarch/xvfcmp-d.c b/src/gcc/testsuite/gcc.target/loongarch/xvfcmp-d.c
new file mode 100644
index 000000000..43f1711fa
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/xvfcmp-d.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mlasx -fno-vect-cost-model -ftree-vectorize" } */
+/* { dg-final { scan-assembler "compare_quiet_equal:.*xvfcmp\\.ceq\\.d.*compare_quiet_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_equal:.*xvfcmp\\.cune\\.d.*compare_quiet_not_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater:.*xvfcmp\\.slt\\.d.*compare_signaling_greater" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater_equal:.*xvfcmp\\.sle\\.d.*compare_signaling_greater_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_less:.*xvfcmp\\.slt\\.d.*compare_signaling_less" } } */
+/* { dg-final { scan-assembler "compare_signaling_less_equal:.*xvfcmp\\.sle\\.d.*compare_signaling_less_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_not_greater:.*xvfcmp\\.sule\\.d.*compare_signaling_not_greater" } } */
+/* { dg-final { scan-assembler "compare_signaling_less_unordered:.*xvfcmp\\.sult\\.d.*compare_signaling_less_unordered" } } */
+/* { dg-final { scan-assembler "compare_signaling_not_less:.*xvfcmp\\.sule\\.d.*compare_signaling_not_less" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater_unordered:.*xvfcmp\\.sult\\.d.*compare_signaling_greater_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_less:.*xvfcmp\\.cule\\.d.*compare_quiet_less" } } */
+/* { dg-final { scan-assembler "compare_quiet_less_equal:.*xvfcmp\\.cult\\.d.*compare_quiet_less_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater:.*xvfcmp\\.cule\\.d.*compare_quiet_greater" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater_equal:.*xvfcmp\\.cult\\.d.*compare_quiet_greater_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_less:.*xvfcmp\\.cule\\.d.*compare_quiet_not_less" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater_unordered:.*xvfcmp\\.cult\\.d.*compare_quiet_greater_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_greater:.*xvfcmp\\.cule\\.d.*compare_quiet_not_greater" } } */
+/* { dg-final { scan-assembler "compare_quiet_less_unordered:.*xvfcmp\\.cult\\.d.*compare_quiet_less_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_unordered:.*xvfcmp\\.cun\\.d.*compare_quiet_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_ordered:.*xvfcmp\\.cor\\.d.*compare_quiet_ordered" } } */
+
+
+#define F double
+#define I long long
+#define VL 32
+
+#include "vfcmp-f.c"
diff --git a/src/gcc/testsuite/gcc.target/loongarch/xvfcmp-f.c b/src/gcc/testsuite/gcc.target/loongarch/xvfcmp-f.c
new file mode 100644
index 000000000..ac661cada
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/xvfcmp-f.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mlasx -fno-vect-cost-model -ftree-vectorize" } */
+/* { dg-final { scan-assembler "compare_quiet_equal:.*vfcmp\\.ceq\\.s.*compare_quiet_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_equal:.*xvfcmp\\.cune\\.s.*compare_quiet_not_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater:.*xvfcmp\\.slt\\.s.*compare_signaling_greater" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater_equal:.*xvfcmp\\.sle\\.s.*compare_signaling_greater_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_less:.*xvfcmp\\.slt\\.s.*compare_signaling_less" } } */
+/* { dg-final { scan-assembler "compare_signaling_less_equal:.*xvfcmp\\.sle\\.s.*compare_signaling_less_equal" } } */
+/* { dg-final { scan-assembler "compare_signaling_not_greater:.*xvfcmp\\.sule\\.s.*compare_signaling_not_greater" } } */
+/* { dg-final { scan-assembler "compare_signaling_less_unordered:.*xvfcmp\\.sult\\.s.*compare_signaling_less_unordered" } } */
+/* { dg-final { scan-assembler "compare_signaling_not_less:.*xvfcmp\\.sule\\.s.*compare_signaling_not_less" } } */
+/* { dg-final { scan-assembler "compare_signaling_greater_unordered:.*xvfcmp\\.sult\\.s.*compare_signaling_greater_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_less:.*xvfcmp\\.cule\\.s.*compare_quiet_less" } } */
+/* { dg-final { scan-assembler "compare_quiet_less_equal:.*xvfcmp\\.cult\\.s.*compare_quiet_less_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater:.*xvfcmp\\.cule\\.s.*compare_quiet_greater" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater_equal:.*xvfcmp\\.cult\\.s.*compare_quiet_greater_equal" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_less:.*xvfcmp\\.cule\\.s.*compare_quiet_not_less" } } */
+/* { dg-final { scan-assembler "compare_quiet_greater_unordered:.*xvfcmp\\.cult\\.s.*compare_quiet_greater_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_not_greater:.*xvfcmp\\.cule\\.s.*compare_quiet_not_greater" } } */
+/* { dg-final { scan-assembler "compare_quiet_less_unordered:.*xvfcmp\\.cult\\.s.*compare_quiet_less_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_unordered:.*xvfcmp\\.cun\\.s.*compare_quiet_unordered" } } */
+/* { dg-final { scan-assembler "compare_quiet_ordered:.*xvfcmp\\.cor\\.s.*compare_quiet_ordered" } } */
+
+#define F float
+#define I int
+#define VL 32
+
+#include "vfcmp-f.c"
+
-- 
2.20.1

