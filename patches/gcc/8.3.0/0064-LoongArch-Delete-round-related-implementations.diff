From b2dfe447b987e5b235f06b6bece4259cf953b881 Mon Sep 17 00:00:00 2001
From: Lulu Cheng <chenglulu@loongson.cn>
Date: Mon, 21 Oct 2024 17:00:53 +0800
Subject: [PATCH 3/3] LoongArch: Delete round-related implementations.

In the LoongArch architecture, there are no directives to implement
round{,f} operations. So here remove the round-related implementations.

Change-Id: If24e2d3fd23a7be65165bc7f4b1db280b4ab4b01
---
 src/gcc/config/loongarch/lasx.md              | 10 ---
 src/gcc/config/loongarch/loongarch-builtins.c | 88 -------------------
 src/gcc/config/loongarch/lsx.md               | 10 ---
 .../testsuite/gcc.target/loongarch/round.c    | 13 +++
 4 files changed, 13 insertions(+), 108 deletions(-)
 create mode 100644 src/gcc/testsuite/gcc.target/loongarch/round.c

diff --git a/src/gcc/config/loongarch/lasx.md b/src/gcc/config/loongarch/lasx.md
index 4b1010d42..908e56112 100644
--- a/src/gcc/config/loongarch/lasx.md
+++ b/src/gcc/config/loongarch/lasx.md
@@ -3580,16 +3580,6 @@
   [(set_attr "type" "simd_shift")
    (set_attr "mode" "V4DF")])
 
-;; Expands to round.
-(define_insn "round<mode>2"
- [(set (match_operand:FLASX 0 "register_operand" "=f")
-	(unspec:FLASX [(match_operand:FLASX 1 "register_operand" "f")]
-			 UNSPEC_LASX_XVFRINT))]
-  "ISA_HAS_LASX"
-  "xvfrint.<flasxfmt>\t%u0,%u1"
-  [(set_attr "type" "simd_shift")
-   (set_attr "mode" "<MODE>")])
-
 ;; Offset load and broadcast
 (define_expand "lasx_xvldrepl_<lasxfmt_f>"
   [(match_operand:LASX 0 "register_operand")
diff --git a/src/gcc/config/loongarch/loongarch-builtins.c b/src/gcc/config/loongarch/loongarch-builtins.c
index 8c89eb908..f5dd03e3d 100644
--- a/src/gcc/config/loongarch/loongarch-builtins.c
+++ b/src/gcc/config/loongarch/loongarch-builtins.c
@@ -2597,99 +2597,11 @@ loongarch_builtin_vectorized_libsleef (combined_fn fn, tree type_out, tree type_
 tree
 loongarch_builtin_vectorized_function (unsigned int fn, tree type_out, tree type_in)
 {
-  machine_mode in_mode, out_mode;
-  int in_n, out_n;
-
   if (TREE_CODE (type_out) != VECTOR_TYPE
       || TREE_CODE (type_in) != VECTOR_TYPE
       || !ISA_HAS_LSX)
     return NULL_TREE;
 
-  out_mode = TYPE_MODE (TREE_TYPE (type_out));
-  out_n = TYPE_VECTOR_SUBPARTS (type_out);
-  in_mode = TYPE_MODE (TREE_TYPE (type_in));
-  in_n = TYPE_VECTOR_SUBPARTS (type_in);
-
-  /* INSN is the name of the associated instruction pattern, without
-     the leading CODE_FOR_.  */
-#define LARCH_GET_BUILTIN(INSN) \
-  loongarch_builtin_decls[loongarch_get_builtin_decl_index[CODE_FOR_##INSN]]
-
-  switch (fn)
-    {
-    CASE_CFN_CEIL:
-      if (out_mode == DFmode && in_mode == DFmode)
-	{
-	  if (out_n == 2 && in_n == 2)
-	    return LARCH_GET_BUILTIN (lsx_vfrintrp_d);
-	  if (out_n == 4 && in_n == 4)
-	    return LARCH_GET_BUILTIN (lasx_xvfrintrp_d);
-	}
-      if (out_mode == SFmode && in_mode == SFmode)
-	{
-	  if (out_n == 4 && in_n == 4)
-	    return LARCH_GET_BUILTIN (lsx_vfrintrp_s);
-	  if (out_n == 8 && in_n == 8)
-	    return LARCH_GET_BUILTIN (lasx_xvfrintrp_s);
-	}
-      break;
-
-    CASE_CFN_TRUNC:
-      if (out_mode == DFmode && in_mode == DFmode)
-	{
-	  if (out_n == 2 && in_n == 2)
-	    return LARCH_GET_BUILTIN (lsx_vfrintrz_d);
-	  if (out_n == 4 && in_n == 4)
-	    return LARCH_GET_BUILTIN (lasx_xvfrintrz_d);
-	}
-      if (out_mode == SFmode && in_mode == SFmode)
-	{
-	  if (out_n == 4 && in_n == 4)
-	    return LARCH_GET_BUILTIN (lsx_vfrintrz_s);
-	  if (out_n == 8 && in_n == 8)
-	    return LARCH_GET_BUILTIN (lasx_xvfrintrz_s);
-	}
-      break;
-
-    CASE_CFN_RINT:
-    CASE_CFN_ROUND:
-      if (out_mode == DFmode && in_mode == DFmode)
-	{
-	  if (out_n == 2 && in_n == 2)
-	    return LARCH_GET_BUILTIN (lsx_vfrint_d);
-	  if (out_n == 4 && in_n == 4)
-	    return LARCH_GET_BUILTIN (lasx_xvfrint_d);
-	}
-      if (out_mode == SFmode && in_mode == SFmode)
-	{
-	  if (out_n == 4 && in_n == 4)
-	    return LARCH_GET_BUILTIN (lsx_vfrint_s);
-	  if (out_n == 8 && in_n == 8)
-	    return LARCH_GET_BUILTIN (lasx_xvfrint_s);
-	}
-      break;
-
-    CASE_CFN_FLOOR:
-      if (out_mode == DFmode && in_mode == DFmode)
-	{
-	  if (out_n == 2 && in_n == 2)
-	    return LARCH_GET_BUILTIN (lsx_vfrintrm_d);
-	  if (out_n == 4 && in_n == 4)
-	    return LARCH_GET_BUILTIN (lasx_xvfrintrm_d);
-	}
-      if (out_mode == SFmode && in_mode == SFmode)
-	{
-	  if (out_n == 4 && in_n == 4)
-	    return LARCH_GET_BUILTIN (lsx_vfrintrm_s);
-	  if (out_n == 8 && in_n == 8)
-	    return LARCH_GET_BUILTIN (lasx_xvfrintrm_s);
-	}
-      break;
-
-    default:
-      break;
-    }
-
   /* Dispatch to a handler for a vectorization library.  */
   if (loongarch_veclibabi_name && strcmp (loongarch_veclibabi_name, "sleef") == 0)
     return loongarch_builtin_vectorized_libsleef (combined_fn (fn), type_out, type_in);
diff --git a/src/gcc/config/loongarch/lsx.md b/src/gcc/config/loongarch/lsx.md
index e4581b314..1f2966a69 100644
--- a/src/gcc/config/loongarch/lsx.md
+++ b/src/gcc/config/loongarch/lsx.md
@@ -3253,16 +3253,6 @@
   [(set_attr "type" "simd_shift")
    (set_attr "mode" "V2DF")])
 
-;; Expands to round.
-(define_insn "round<mode>2"
- [(set (match_operand:FLSX 0 "register_operand" "=f")
-	(unspec:FLSX [(match_operand:FLSX 1 "register_operand" "f")]
-			 UNSPEC_LSX_VFRINT))]
-  "ISA_HAS_LSX"
-  "vfrint.<flsxfrint>\t%w0,%w1"
-  [(set_attr "type" "simd_shift")
-   (set_attr "mode" "<MODE>")])
-
 ;; Offset load and broadcast
 (define_expand "lsx_vldrepl_<lsxfmt_f>"
   [(match_operand:LSX 0 "register_operand")
diff --git a/src/gcc/testsuite/gcc.target/loongarch/round.c b/src/gcc/testsuite/gcc.target/loongarch/round.c
new file mode 100644
index 000000000..eea582dae
--- /dev/null
+++ b/src/gcc/testsuite/gcc.target/loongarch/round.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-Ofast -mlsx" } */
+/* { dg-final { scan-assembler-not "vfrint" } } */
+
+float roundf (float x);
+float b[16];
+float
+test (float a[16])
+{
+  for (int i = 0; i < 16; i++)
+    b[i] = roundf (a[i]);
+}
+
-- 
2.39.3

