diff --git a/src/gcc/config/loongarch/genopts/loongarch.opt.in b/src/gcc/config/loongarch/genopts/loongarch.opt.in
index c3538eb27..d1ec5f8a7 100644
--- a/src/gcc/config/loongarch/genopts/loongarch.opt.in
+++ b/src/gcc/config/loongarch/genopts/loongarch.opt.in
@@ -151,6 +151,10 @@ mmemvec-cost=
 Target RejectNegative Joined UInteger Var(loongarch_vector_access_cost) IntegerRange(1, 5)
 mmemvec-cost=COST      Set the cost of vector memory access instructions.
 
+mveclibabi=
+Target RejectNegative Joined Var(loongarch_veclibabi_name)
+Vector library ABI to use.
+
 mcheck-zero-division
 Target Mask(CHECK_ZERO_DIV)
 Trap on integer divide by zero.
diff --git a/src/gcc/config/loongarch/lasxintrin.h b/src/gcc/config/loongarch/lasxintrin.h
index 185eee869..9feaa5715 100644
--- a/src/gcc/config/loongarch/lasxintrin.h
+++ b/src/gcc/config/loongarch/lasxintrin.h
@@ -3325,7 +3325,7 @@ __m256i __lasx_xvfrintrm_d(__m256d _1)
 
 /* Assembly instruction format:          xd, rj, si12.  */
 /* Data types in instruction templates:  V32QI, CVPOINTER, SI.  */
-#define __lasx_xvld(/*void **/ _1, /*si12*/ _2)	((__m256i)__builtin_lasx_xvld((void *)(_1), (_2)))
+#define __lasx_xvld(/*void **/ _1, /*si12*/ _2)	((__m256i)__builtin_lasx_xvld((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          xd, rj, si12.  */
 /* Data types in instruction templates:  VOID, V32QI, CVPOINTER, SI.  */
@@ -3426,9 +3426,9 @@ __m256i __lasx_xvorn_v(__m256i _1, __m256i _2)
 /* Assembly instruction format:          xd, rj, rk.  */
 /* Data types in instruction templates:  V32QI, CVPOINTER, DI.  */
 extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-__m256i __lasx_xvldx(void * _1, long int _2)
+__m256i __lasx_xvldx(void const * _1, long int _2)
 {
-	return (__m256i)__builtin_lasx_xvldx((void *)_1, (long int)_2);
+	return (__m256i)__builtin_lasx_xvldx((void const *)_1, (long int)_2);
 }
 
 /* Assembly instruction format:          xd, rj, rk.  */
@@ -3609,19 +3609,19 @@ __m256i __lasx_xvperm_w(__m256i _1, __m256i _2)
 
 /* Assembly instruction format:          xd, rj, si12.  */
 /* Data types in instruction templates:  V32QI, CVPOINTER, SI.  */
-#define __lasx_xvldrepl_b(/*void **/ _1, /*si12*/ _2)	((__m256i)__builtin_lasx_xvldrepl_b((void *)(_1), (_2)))
+#define __lasx_xvldrepl_b(/*void **/ _1, /*si12*/ _2)	((__m256i)__builtin_lasx_xvldrepl_b((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          xd, rj, si11.  */
 /* Data types in instruction templates:  V16HI, CVPOINTER, SI.  */
-#define __lasx_xvldrepl_h(/*void **/ _1, /*si11*/ _2)	((__m256i)__builtin_lasx_xvldrepl_h((void *)(_1), (_2)))
+#define __lasx_xvldrepl_h(/*void **/ _1, /*si11*/ _2)	((__m256i)__builtin_lasx_xvldrepl_h((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          xd, rj, si10.  */
 /* Data types in instruction templates:  V8SI, CVPOINTER, SI.  */
-#define __lasx_xvldrepl_w(/*void **/ _1, /*si10*/ _2)	((__m256i)__builtin_lasx_xvldrepl_w((void *)(_1), (_2)))
+#define __lasx_xvldrepl_w(/*void **/ _1, /*si10*/ _2)	((__m256i)__builtin_lasx_xvldrepl_w((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          xd, rj, si9.  */
 /* Data types in instruction templates:  V4DI, CVPOINTER, SI.  */
-#define __lasx_xvldrepl_d(/*void **/ _1, /*si9*/ _2)	((__m256i)__builtin_lasx_xvldrepl_d((void *)(_1), (_2)))
+#define __lasx_xvldrepl_d(/*void **/ _1, /*si9*/ _2)	((__m256i)__builtin_lasx_xvldrepl_d((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          rd, xj, ui3.  */
 /* Data types in instruction templates:  SI, V8SI, UQI.  */
diff --git a/src/gcc/config/loongarch/loongarch-builtins.c b/src/gcc/config/loongarch/loongarch-builtins.c
index 177ef8db9..1de105ffe 100644
--- a/src/gcc/config/loongarch/loongarch-builtins.c
+++ b/src/gcc/config/loongarch/loongarch-builtins.c
@@ -38,6 +38,9 @@ along with GCC; see the file COPYING3.  If not see
 #include "langhooks.h"
 #include "emit-rtl.h"
 #include "explow.h"
+#include "builtins.h"
+#include "stringpool.h"
+#include "case-cfn-macros.h"
 
 /* Macros to create an enumeration identifier for a function prototype.  */
 #define LARCH_FTYPE_NAME1(A, B) LARCH_##A##_FTYPE_##B
@@ -2482,6 +2485,104 @@ loongarch_builtin_decl (unsigned int code, bool initialize_p ATTRIBUTE_UNUSED)
   return loongarch_builtin_decls[code];
 }
 
+/* Handler for an SLEEF-style interface to
+   a library with vectorized intrinsics.  */
+static tree
+loongarch_builtin_vectorized_libsleef (combined_fn fn, tree type_out, tree type_in)
+{
+  char name[20];
+  tree fntype, new_fndecl;
+  unsigned args = 1;
+  const char *bname;
+  machine_mode el_mode, in_mode;
+  int n, in_n;
+
+  /* The SLEEF is suitable for unsafe math only.  */
+  if (!flag_unsafe_math_optimizations || !ISA_HAS_LSX)
+    return NULL_TREE;
+
+  el_mode = TYPE_MODE (TREE_TYPE (type_out));
+  n = TYPE_VECTOR_SUBPARTS (type_out);
+  in_mode = TYPE_MODE (TREE_TYPE (type_in));
+  in_n = TYPE_VECTOR_SUBPARTS (type_in);
+  if (el_mode != in_mode
+      || n != in_n)
+    return NULL_TREE;
+
+  switch (fn)
+    {
+    CASE_CFN_ATAN2:
+    CASE_CFN_POW:
+      args = 2;
+      gcc_fallthrough ();
+
+    CASE_CFN_EXP:
+    CASE_CFN_LOG:
+    CASE_CFN_LOG1P:
+    CASE_CFN_LOG2:
+    CASE_CFN_LOG10:
+    CASE_CFN_TANH:
+    CASE_CFN_TAN:
+    CASE_CFN_ATAN:
+    CASE_CFN_ATANH:
+    CASE_CFN_CBRT:
+    CASE_CFN_SINH:
+    CASE_CFN_SIN:
+    CASE_CFN_ASINH:
+    CASE_CFN_ASIN:
+    CASE_CFN_COSH:
+    CASE_CFN_COS:
+    CASE_CFN_ACOSH:
+    CASE_CFN_ACOS:
+      break;
+
+    default:
+      return NULL_TREE;
+    }
+
+  tree fndecl = mathfn_built_in (TREE_TYPE (type_in), fn);
+  bname = IDENTIFIER_POINTER (DECL_NAME (fndecl));
+
+  if (args == 1)
+    {
+      if (n == 8 && el_mode == SFmode)
+	sprintf (name, "_ZGVdN8v_%s", bname+10);
+      else if (n == 4 && el_mode == DFmode)
+	sprintf (name, "_ZGVdN4v_%s", bname+10);
+      else if (n == 4 && el_mode == SFmode)
+	sprintf (name, "_ZGVbN4v_%s", bname+10);
+      else
+	sprintf (name, "_ZGVbN2v_%s", bname+10);
+
+      fntype = build_function_type_list (type_out, type_in, NULL);
+    }
+  else if (args == 2)
+    {
+      if (n == 8 && el_mode == SFmode)
+	sprintf (name, "_ZGVdN8vv_%s", bname+10);
+      else if (n == 4 && el_mode == DFmode)
+	sprintf (name, "_ZGVdN4vv_%s", bname+10);
+      else if (n == 4 && el_mode == SFmode)
+	sprintf (name, "_ZGVbN4vv_%s", bname+10);
+      else
+	sprintf (name, "_ZGVbN2vv_%s", bname+10);
+
+      fntype = build_function_type_list (type_out, type_in, type_in, NULL);
+    }
+  else
+    gcc_unreachable ();
+
+  /* Build a function declaration for the vectorized function.  */
+  new_fndecl = build_decl (BUILTINS_LOCATION,
+			   FUNCTION_DECL, get_identifier (name), fntype);
+  TREE_PUBLIC (new_fndecl) = 1;
+  DECL_EXTERNAL (new_fndecl) = 1;
+  DECL_IS_NOVOPS (new_fndecl) = 1;
+  TREE_READONLY (new_fndecl) = 1;
+
+  return new_fndecl;
+}
+
 /* Implement TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION.  */
 
 tree
@@ -2507,20 +2608,82 @@ loongarch_builtin_vectorized_function (unsigned int fn, tree type_out, tree type
 
   switch (fn)
     {
-    case BUILT_IN_SQRT:
-      if (out_mode == DFmode && out_n == 2
-	  && in_mode == DFmode && in_n == 2)
-	return LARCH_GET_BUILTIN (lsx_vfsqrt_d);
+    CASE_CFN_CEIL:
+      if (out_mode == DFmode && in_mode == DFmode)
+	{
+	  if (out_n == 2 && in_n == 2)
+	    return LARCH_GET_BUILTIN (lsx_vfrintrp_d);
+	  if (out_n == 4 && in_n == 4)
+	    return LARCH_GET_BUILTIN (lasx_xvfrintrp_d);
+	}
+      if (out_mode == SFmode && in_mode == SFmode)
+	{
+	  if (out_n == 4 && in_n == 4)
+	    return LARCH_GET_BUILTIN (lsx_vfrintrp_s);
+	  if (out_n == 8 && in_n == 8)
+	    return LARCH_GET_BUILTIN (lasx_xvfrintrp_s);
+	}
+      break;
+
+    CASE_CFN_TRUNC:
+      if (out_mode == DFmode && in_mode == DFmode)
+	{
+	  if (out_n == 2 && in_n == 2)
+	    return LARCH_GET_BUILTIN (lsx_vfrintrz_d);
+	  if (out_n == 4 && in_n == 4)
+	    return LARCH_GET_BUILTIN (lasx_xvfrintrz_d);
+	}
+      if (out_mode == SFmode && in_mode == SFmode)
+	{
+	  if (out_n == 4 && in_n == 4)
+	    return LARCH_GET_BUILTIN (lsx_vfrintrz_s);
+	  if (out_n == 8 && in_n == 8)
+	    return LARCH_GET_BUILTIN (lasx_xvfrintrz_s);
+	}
       break;
-    case BUILT_IN_SQRTF:
-      if (out_mode == SFmode && out_n == 4
-	  && in_mode == SFmode && in_n == 4)
-	return LARCH_GET_BUILTIN (lsx_vfsqrt_s);
+
+    CASE_CFN_RINT:
+    CASE_CFN_ROUND:
+      if (out_mode == DFmode && in_mode == DFmode)
+	{
+	  if (out_n == 2 && in_n == 2)
+	    return LARCH_GET_BUILTIN (lsx_vfrint_d);
+	  if (out_n == 4 && in_n == 4)
+	    return LARCH_GET_BUILTIN (lasx_xvfrint_d);
+	}
+      if (out_mode == SFmode && in_mode == SFmode)
+	{
+	  if (out_n == 4 && in_n == 4)
+	    return LARCH_GET_BUILTIN (lsx_vfrint_s);
+	  if (out_n == 8 && in_n == 8)
+	    return LARCH_GET_BUILTIN (lasx_xvfrint_s);
+	}
+      break;
+
+    CASE_CFN_FLOOR:
+      if (out_mode == DFmode && in_mode == DFmode)
+	{
+	  if (out_n == 2 && in_n == 2)
+	    return LARCH_GET_BUILTIN (lsx_vfrintrm_d);
+	  if (out_n == 4 && in_n == 4)
+	    return LARCH_GET_BUILTIN (lasx_xvfrintrm_d);
+	}
+      if (out_mode == SFmode && in_mode == SFmode)
+	{
+	  if (out_n == 4 && in_n == 4)
+	    return LARCH_GET_BUILTIN (lsx_vfrintrm_s);
+	  if (out_n == 8 && in_n == 8)
+	    return LARCH_GET_BUILTIN (lasx_xvfrintrm_s);
+	}
       break;
+
     default:
       break;
     }
 
+  /* Dispatch to a handler for a vectorization library.  */
+  if (loongarch_veclibabi_name && strcmp (loongarch_veclibabi_name, "sleef") == 0)
+    return loongarch_builtin_vectorized_libsleef (combined_fn (fn), type_out, type_in);
   return NULL_TREE;
 }
 
diff --git a/src/gcc/config/loongarch/loongarch.c b/src/gcc/config/loongarch/loongarch.c
index aad8fd138..6c7bde8bb 100644
--- a/src/gcc/config/loongarch/loongarch.c
+++ b/src/gcc/config/loongarch/loongarch.c
@@ -382,8 +382,8 @@ loongarch_flatten_aggregate_argument (const_tree type,
 				      loongarch_aggregate_field fields[2],
 				      const int use_vecarg_p)
 {
-  if (!type || (TREE_CODE (type) != RECORD_TYPE
-		|| (use_vecarg_p && TREE_CODE (type) == VECTOR_TYPE)))
+  if (!type || !((TREE_CODE (type) == RECORD_TYPE)
+		 || (use_vecarg_p && TREE_CODE (type) == VECTOR_TYPE)))
     return -1;
 
   return loongarch_flatten_aggregate_field (type, fields, 0, 0, use_vecarg_p);
@@ -6697,6 +6697,15 @@ loongarch_option_override_internal (struct gcc_options *opts,
       if (opts->x_align_functions <= 0)
 	opts->x_align_functions = 16;
     }
+
+  if (loongarch_veclibabi_name
+      && strcmp (loongarch_veclibabi_name, "sleef") != 0)
+    {
+      error ("unknown vectorization library ABI type (%qs) for "
+	     "%qs", loongarch_veclibabi_name, "-mveclibabi=");
+      inform (input_location,
+	      "valid arguments to %<-mveclibabi=%> are: %s", "sleef");
+    }
 }
 
 
@@ -10191,6 +10200,10 @@ loongarch_build_signbit_mask (machine_mode mode, bool vect, bool invert)
 #define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES \
   loongarch_autovectorize_vector_sizes
 
+#undef TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION
+#define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION \
+  loongarch_builtin_vectorized_function
+
 #undef TARGET_INIT_BUILTINS
 #define TARGET_INIT_BUILTINS loongarch_init_builtins
 #undef TARGET_BUILTIN_DECL
diff --git a/src/gcc/config/loongarch/loongarch.opt b/src/gcc/config/loongarch/loongarch.opt
index 562acc8ad..14d7f3e46 100644
--- a/src/gcc/config/loongarch/loongarch.opt
+++ b/src/gcc/config/loongarch/loongarch.opt
@@ -158,6 +158,10 @@ mmemvec-cost=
 Target RejectNegative Joined UInteger Var(loongarch_vector_access_cost) IntegerRange(1, 5)
 mmemvec-cost=COST      Set the cost of vector memory access instructions.
 
+mveclibabi=
+Target RejectNegative Joined Var(loongarch_veclibabi_name)
+Vector library ABI to use.
+
 mcheck-zero-division
 Target Mask(CHECK_ZERO_DIV)
 Trap on integer divide by zero.
diff --git a/src/gcc/config/loongarch/lsxintrin.h b/src/gcc/config/loongarch/lsxintrin.h
index fe3043e3d..a0b16d28d 100644
--- a/src/gcc/config/loongarch/lsxintrin.h
+++ b/src/gcc/config/loongarch/lsxintrin.h
@@ -4154,19 +4154,19 @@ __m128i __lsx_vsub_q(__m128i _1, __m128i _2)
 
 /* Assembly instruction format:          vd, rj, si12.  */
 /* Data types in instruction templates:  V16QI, CVPOINTER, SI.  */
-#define __lsx_vldrepl_b(/*void **/ _1, /*si12*/ _2)	((__m128i)__builtin_lsx_vldrepl_b((void *)(_1), (_2)))
+#define __lsx_vldrepl_b(/*void **/ _1, /*si12*/ _2)	((__m128i)__builtin_lsx_vldrepl_b((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          vd, rj, si11.  */
 /* Data types in instruction templates:  V8HI, CVPOINTER, SI.  */
-#define __lsx_vldrepl_h(/*void **/ _1, /*si11*/ _2)	((__m128i)__builtin_lsx_vldrepl_h((void *)(_1), (_2)))
+#define __lsx_vldrepl_h(/*void **/ _1, /*si11*/ _2)	((__m128i)__builtin_lsx_vldrepl_h((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          vd, rj, si10.  */
 /* Data types in instruction templates:  V4SI, CVPOINTER, SI.  */
-#define __lsx_vldrepl_w(/*void **/ _1, /*si10*/ _2)	((__m128i)__builtin_lsx_vldrepl_w((void *)(_1), (_2)))
+#define __lsx_vldrepl_w(/*void **/ _1, /*si10*/ _2)	((__m128i)__builtin_lsx_vldrepl_w((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          vd, rj, si9.  */
 /* Data types in instruction templates:  V2DI, CVPOINTER, SI.  */
-#define __lsx_vldrepl_d(/*void **/ _1, /*si9*/ _2)	((__m128i)__builtin_lsx_vldrepl_d((void *)(_1), (_2)))
+#define __lsx_vldrepl_d(/*void **/ _1, /*si9*/ _2)	((__m128i)__builtin_lsx_vldrepl_d((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          vd, vj.  */
 /* Data types in instruction templates:  V16QI, V16QI.  */
@@ -4470,7 +4470,7 @@ __m128i __lsx_vextl_q_d(__m128i _1)
 
 /* Assembly instruction format:          vd, rj, si12.  */
 /* Data types in instruction templates:  V16QI, CVPOINTER, SI.  */
-#define __lsx_vld(/*void **/ _1, /*si12*/ _2)	((__m128i)__builtin_lsx_vld((void *)(_1), (_2)))
+#define __lsx_vld(/*void **/ _1, /*si12*/ _2)	((__m128i)__builtin_lsx_vld((void const *)(_1), (_2)))
 
 /* Assembly instruction format:          vd, rj, si12.  */
 /* Data types in instruction templates:  VOID, V16QI, CVPOINTER, SI.  */
@@ -4547,9 +4547,9 @@ __m128i __lsx_vshuf_b(__m128i _1, __m128i _2, __m128i _3)
 /* Assembly instruction format:          vd, rj, rk.  */
 /* Data types in instruction templates:  V16QI, CVPOINTER, DI.  */
 extern __inline __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-__m128i __lsx_vldx(void * _1, long int _2)
+__m128i __lsx_vldx(void const * _1, long int _2)
 {
-	return (__m128i)__builtin_lsx_vldx((void *)_1, (long int)_2);
+	return (__m128i)__builtin_lsx_vldx((void const *)_1, (long int)_2);
 }
 
 /* Assembly instruction format:          vd, rj, rk.  */
diff --git a/src/include/vtv-change-permission.h b/src/include/vtv-change-permission.h
index 92aa50f94..9183f8e44 100644
--- a/src/include/vtv-change-permission.h
+++ b/src/include/vtv-change-permission.h
@@ -45,9 +45,11 @@ extern void __VLTChangePermission (int);
 #ifdef BIG_PAGE_SIZE
 /* TODO - Replace '4096' below with correct big page size.  */
 #define VTV_PAGE_SIZE 4096
-#else 
+#else
 #if defined(__sun__) && defined(__svr4__) && defined(__sparc__)
 #define VTV_PAGE_SIZE 8192
+#elif defined(__loongarch__)
+#define VTV_PAGE_SIZE 16384
 #else
 #define VTV_PAGE_SIZE 4096
 #endif
diff --git a/src/libitm/config/loongarch/asm.h b/src/libitm/config/loongarch/asm.h
new file mode 100644
index 000000000..84c8e980b
--- /dev/null
+++ b/src/libitm/config/loongarch/asm.h
@@ -0,0 +1,54 @@
+/* Copyright (C) 2014-2018 Free Software Foundation, Inc.
+   Contributed by Loongson Co. Ltd.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LA_ASM_H
+#define _LA_ASM_H
+
+#if defined(__loongarch_lp64)
+#  define GPR_L ld.d
+#  define GPR_S st.d
+#  define SZ_GPR 8
+#  define ADDSP(si)   addi.d  $sp, $sp, si
+#elif defined(__loongarch64_ilp32)
+#  define GPR_L ld.w
+#  define GPR_S st.w
+#  define SZ_GPR 4
+#  define ADDSP(si)   addi.w  $sp, $sp, si
+#else
+#  error Unsupported GPR size (must be 64-bit or 32-bit).
+#endif
+
+#if defined(__loongarch_double_float)
+#  define FPR_L fld.d
+#  define FPR_S fst.d
+#  define SZ_FPR 8
+#elif defined(__loongarch_single_float)
+#  define FPR_L fld.s
+#  define FPR_S fst.s
+#  define SZ_FPR 4
+#else
+#  define SZ_FPR 0
+#endif
+
+#endif  /* _LA_ASM_H */
diff --git a/src/libitm/config/loongarch/sjlj.S b/src/libitm/config/loongarch/sjlj.S
new file mode 100644
index 000000000..3ffdd50cf
--- /dev/null
+++ b/src/libitm/config/loongarch/sjlj.S
@@ -0,0 +1,127 @@
+/* Copyright (C) 2014-2018 Free Software Foundation, Inc.
+   Contributed by Loongson Co. Ltd.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "asmcfi.h"
+#include "asm.h"
+
+	.text
+	.align	2
+	.global	_ITM_beginTransaction
+	.type	_ITM_beginTransaction, @function
+
+_ITM_beginTransaction:
+        cfi_startproc
+        move   $r5, $sp
+        ADDSP(-(12*SZ_GPR+8*SZ_FPR))
+        cfi_adjust_cfa_offset(12*SZ_GPR+8*SZ_FPR)
+
+        /* Frame Pointer */
+        GPR_S  $fp, $sp, 0*SZ_GPR
+        cfi_rel_offset(22, 0)
+
+        /* Return Address */
+        GPR_S  $r1, $sp, 1*SZ_GPR
+        cfi_rel_offset(1, SZ_GPR)
+
+        /* Caller's $sp */
+        GPR_S  $r5, $sp, 2*SZ_GPR
+
+        /* Callee-saved scratch GPRs (r23-r31) */
+        GPR_S  $s0, $sp, 3*SZ_GPR
+        GPR_S  $s1, $sp, 4*SZ_GPR
+        GPR_S  $s2, $sp, 5*SZ_GPR
+        GPR_S  $s3, $sp, 6*SZ_GPR
+        GPR_S  $s4, $sp, 7*SZ_GPR
+        GPR_S  $s5, $sp, 8*SZ_GPR
+        GPR_S  $s6, $sp, 9*SZ_GPR
+        GPR_S  $s7, $sp, 10*SZ_GPR
+        GPR_S  $s8, $sp, 11*SZ_GPR
+
+#if !defined(__loongarch_soft_float)
+        /* Callee-saved scratch FPRs (f24-f31) */
+        FPR_S  $f24, $sp, 12*SZ_GPR + 0*SZ_FPR
+        FPR_S  $f25, $sp, 12*SZ_GPR + 1*SZ_FPR
+        FPR_S  $f26, $sp, 12*SZ_GPR + 2*SZ_FPR
+        FPR_S  $f27, $sp, 12*SZ_GPR + 3*SZ_FPR
+        FPR_S  $f28, $sp, 12*SZ_GPR + 4*SZ_FPR
+        FPR_S  $f29, $sp, 12*SZ_GPR + 5*SZ_FPR
+        FPR_S  $f30, $sp, 12*SZ_GPR + 6*SZ_FPR
+        FPR_S  $f31, $sp, 12*SZ_GPR + 7*SZ_FPR
+#endif
+        move   $fp, $sp
+
+        /* Invoke GTM_begin_transaction with the struct we've just built.  */
+        move   $r5, $sp
+        bl     %plt(GTM_begin_transaction)
+
+        /* Return. (no call-saved scratch reg needs to be restored here)  */
+        GPR_L  $fp, $sp, 0*SZ_GPR
+        cfi_restore(22)
+        GPR_L  $r1, $sp, 1*SZ_GPR
+        cfi_restore(1)
+
+        ADDSP(12*SZ_GPR+8*SZ_FPR)
+        cfi_adjust_cfa_offset(-(12*SZ_GPR+8*SZ_FPR))
+
+        jr     $r1
+        cfi_endproc
+	.size	_ITM_beginTransaction, . - _ITM_beginTransaction
+
+	.align	2
+	.global	GTM_longjmp
+	.hidden	GTM_longjmp
+	.type	GTM_longjmp, @function
+
+GTM_longjmp:
+        cfi_startproc
+        GPR_L  $s0, $r5, 3*SZ_GPR
+        GPR_L  $s1, $r5, 4*SZ_GPR
+        GPR_L  $s2, $r5, 5*SZ_GPR
+        GPR_L  $s3, $r5, 6*SZ_GPR
+        GPR_L  $s4, $r5, 7*SZ_GPR
+        GPR_L  $s5, $r5, 8*SZ_GPR
+        GPR_L  $s6, $r5, 9*SZ_GPR
+        GPR_L  $s7, $r5, 10*SZ_GPR
+        GPR_L  $s8, $r5, 11*SZ_GPR
+
+        FPR_L  $f24, $r5, 12*SZ_GPR + 0*SZ_FPR
+        FPR_L  $f25, $r5, 12*SZ_GPR + 1*SZ_FPR
+        FPR_L  $f26, $r5, 12*SZ_GPR + 2*SZ_FPR
+        FPR_L  $f27, $r5, 12*SZ_GPR + 3*SZ_FPR
+        FPR_L  $f28, $r5, 12*SZ_GPR + 4*SZ_FPR
+        FPR_L  $f29, $r5, 12*SZ_GPR + 5*SZ_FPR
+        FPR_L  $f30, $r5, 12*SZ_GPR + 6*SZ_FPR
+        FPR_L  $f31, $r5, 12*SZ_GPR + 7*SZ_FPR
+
+        GPR_L  $r7, $r5, 2*SZ_GPR
+        GPR_L  $fp, $r5, 0*SZ_GPR
+        GPR_L  $r1, $r5, 1*SZ_GPR
+        cfi_def_cfa(5, 0)
+        move   $sp, $r7
+        jr     $r1
+        cfi_endproc
+	.size	GTM_longjmp, . - GTM_longjmp
+
+#ifdef __linux__
+.section .note.GNU-stack, "", @progbits
+#endif
diff --git a/src/libitm/config/loongarch/target.h b/src/libitm/config/loongarch/target.h
new file mode 100644
index 000000000..2853bf203
--- /dev/null
+++ b/src/libitm/config/loongarch/target.h
@@ -0,0 +1,50 @@
+/* Copyright (C) 2014-2018 Free Software Foundation, Inc.
+   Contributed by Loongson Co. Ltd.
+
+   This file is part of the GNU Transactional Memory Library (libitm).
+
+   Libitm is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+namespace GTM HIDDEN {
+
+typedef struct gtm_jmpbuf
+  {
+    long int fp;        /* Frame Pointer: r22 */
+    long int pc;        /* Return Address: r1 */
+    void *cfa;          /* CFA: r3 */
+    long int gpr[9];	/* Callee-saved scratch GPRs: r23(s0)-r31(s8) */
+
+    /* Callee-saved scratch FPRs: f24-f31 */
+#if defined(__loongarch_double_float)
+    double fpr[8];
+#elif defined(__loongarch_single_float)
+    float fpr[8];
+#endif
+  } gtm_jmpbuf;
+
+#define HW_CACHELINE_SIZE 128
+
+static inline void
+cpu_relax (void)
+{
+    __asm__ volatile ("" : : : "memory");
+}
+
+} // namespace GTM
diff --git a/src/libitm/configure.tgt b/src/libitm/configure.tgt
index eda72c83b..99e614a1f 100644
--- a/src/libitm/configure.tgt
+++ b/src/libitm/configure.tgt
@@ -69,6 +69,8 @@ case "${target_cpu}" in
 	ARCH=x86
 	;;
 
+  loongarch*)   ARCH=loongarch ;;
+
   sh*)		ARCH=sh ;;
 
   sparc)
diff --git a/src/libvtv/configure.tgt b/src/libvtv/configure.tgt
index 9eb4f6333..7d67ee283 100644
--- a/src/libvtv/configure.tgt
+++ b/src/libvtv/configure.tgt
@@ -50,6 +50,9 @@ case "${target}" in
 	;;
   x86_64-*-darwin[1]* | i?86-*-darwin[1]*)
 	;;
+  loongarch*-*-linux*)
+	VTV_SUPPORTED=yes
+	;;
   *)
 	;;
 esac
diff --git a/src/libvtv/testsuite/lib/libvtv-dg.exp b/src/libvtv/testsuite/lib/libvtv-dg.exp
index b140c194c..454d916e5 100644
--- a/src/libvtv/testsuite/lib/libvtv-dg.exp
+++ b/src/libvtv/testsuite/lib/libvtv-dg.exp
@@ -12,6 +12,8 @@
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 
+load_gcc_lib scansarif.exp
+
 proc libvtv-dg-test { prog do_what extra_tool_flags } {
     return [gcc-dg-test-1 libvtv_target_compile $prog $do_what $extra_tool_flags]
 }
